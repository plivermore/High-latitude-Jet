 MODULE SUBS
USE FLOW_INTEGRALS
IMPLICIT NONE
#include <fftw3.f>
     ! OPTIONS:
! FFTW_ESTIMATE - a fast but probably inefficient FFT plan
! FFTW_MEASURE - does a few FFTs to gauge the machine speed
! FFTW_PATIENT - searches a range of algorithms to find the best one
! FFTW_EXHAUSTIVE - does a complete algorithm search, including some unlikely ones, to find the fastest. NB - may be slow to compute the plan.
  INTEGER, PARAMETER :: TRANSFORM_OPTIMISATION = FFTW_PATIENT  
  INTEGER( KIND = 8) ::  PLAN_FFT_R2HC

INTEGER, PARAMETER :: TOROIDAL_FLOW = 1, POLOIDAL_FLOW = 2

TYPE HARMONIC_STRUCTURE
    INTEGER L, M
    INTEGER SINCOS
    END TYPE HARMONIC_STRUCTURE

INTEGER, PARAMETER :: EXTRA_LONG_REAL = 16, LONG_REAL = 8

REAL( KIND = LONG_REAL), ALLOCATABLE, DIMENSION(:,:) :: FFT_TRANSFORM_ARRAY

REAL( KIND = 8), PARAMETER :: ICB_CMB_RATIO = 1221.0_8/3480.0_8, CMB_RADIUS = 3480.0E3_8, ES_RADIUS = 6371.0E3_8, Pi = 3.14159265358979_8
INTEGER, PARAMETER :: COSINE_HARMONIC = 1, SINE_HARMONIC = 2

INTEGER, PARAMETER :: NTHETA_GRID_CONTOUR_GMT = 100, NPHI_GRID_CONTOUR_GMT = 200  !number of points for contour plots in GMT/Python

CONTAINS


SUBROUTINE GAUWTS ( NTHPTS, GAUX, GAUW )
      IMPLICIT NONE
! Computes the integration points and weights needed for Legendre transforms:

! INPUTS:
! NTHPTS    (INTEGER)
!           number of points in theta direction
! GAUX     ( REAL( KIND= LONG_REAL) ), dimension(1:NTHPTS)
!          The abscissae of the Gauss-Legendre integration, in cos(theta)
! GAUW     ( REAL( KIND= LONG_REAL) ), dimension(1:NTHPTS)
!          The weights of the Gauss-Legendre integration
!

      INTEGER NTHPTS
      REAL (KIND = LONG_REAL) GAUX( 1: NTHPTS ), GAUW( 1: NTHPTS )
      INTENT(IN) NTHPTS
      INTENT(OUT) GAUX, GAUW
!
      INTEGER M,I,J
      REAL (KIND = LONG_REAL) XM,XL,P1,P2,P3,EPS,PP,Z,Z1
      PARAMETER (EPS=1.0E-13_LONG_REAL)
      
      REAL (KIND = LONG_REAL), PARAMETER ::  X1 = -1.0_LONG_REAL, X2 = 1.0_LONG_REAL
    
! ....... the roots are symmetric in the interval so need only find
! half of them.
      M = ( NTHPTS + 1 )/2
      XM = 0.5_LONG_REAL * ( X2 + X1 )
      XL = 0.5_LONG_REAL * ( X2 - X1 )
! ........start looping over the desired roots .......................
      DO I = 1, M
         Z = COS( PI*( REAL (I, KIND = LONG_REAL) - 0.25_LONG_REAL)/( REAL(NTHPTS, KIND=LONG_REAL) + 0.5_LONG_REAL ))
!           ..... starting with this approximation to the Ith root, we
!                enter the main loop of refinement by Newton's method.
 100     CONTINUE
            P1 = 1.0_LONG_REAL
            P2 = 0.0_LONG_REAL
!           ........... Loop up the recurrence relation to get the
!                      legendre Polynomial evaluated at Z.
            DO J = 1, NTHPTS
               P3 = P2
               P2 = P1
               P1 = ((2.0_LONG_REAL*J-1.0_LONG_REAL)*Z*P2 - (J-1.0_LONG_REAL)*P3)/REAL( J, KIND=LONG_REAL )
            ENDDO
!           ..................... finish recurrence relation loop ...
! ... P1 is now the desired Legendre Polynomial. We now compute PP,
!    its derivative by a standard relation involving also P2, the 
!    polynomial of one order lower.
            PP = NTHPTS*(Z*P1-P2)/(Z*Z-1.0_LONG_REAL)
            Z1 = Z
            Z = Z1 - P1/PP
         IF ( ABS(Z-Z1).GT.EPS ) GOTO 100
! ...........scale the root to the desired interval .................
         GAUX( I ) = XM - XL*Z
! ...........and add its symmetric counterpart ......................
         GAUX( NTHPTS+1-I ) = XM + XL*Z
! ...........calculate the weight ...................................
         GAUW( I ) = 2.0_LONG_REAL*XL/((1.0_LONG_REAL-Z*Z)*PP*PP)
! ...........and add its symmetric counterpart ......................
         GAUW( NTHPTS + 1 - I ) = GAUW( I )
      ENDDO
! ......... end looping over the desired roots .......................
      RETURN
      END SUBROUTINE GAUWTS
!*********************************************************************




   SUBROUTINE GET_LEGENDRE_FUNCTIONS(COSTHETA_ARR, LMAX, MMAX, Y, dY)
IMPLICIT NONE
! Computes the required derivatives of the associated Legendre functions in EXTRA_LONG_REAL precision
! The arrays Y and dY are returned, which contain the elements
! P_l^m and d P_l^m/d theta in the harmonic ordering where
! the l's are consecutive
! Dimensions of Y etc. are: (grid, HARMONICS)
!
! Uses the recursion relations in A&S modified for fully normalised associated Legendre functions to compute
! P_m^m, P_m+1^m and then P_l^m.....
!
! Uses the recursion relation involving the derivative and multiple orders to compute d P_l^m / d(theta)


REAL (KIND = EXTRA_LONG_REAL) :: COSTHETA_ARR(1:)
INTEGER :: LMAX, MMAX
REAL (KIND = EXTRA_LONG_REAL) :: Y(1:,1:), dY(1:,1:)

REAL( KIND = EXTRA_LONG_REAL) ::  SINTHETA,PMM, PMM1, COSTHETA, FAC1, FAC2, SINSQINV, FACTOR
INTEGER :: NUM, INDEX, I, M , J, L

      DO I = 1, SIZE(COSTHETA_ARR)
      COSTHETA = COSTHETA_ARR(I)
      SINTHETA = SQRT( (1.0_EXTRA_LONG_REAL-COSTHETA) * (1.0_EXTRA_LONG_REAL + COSTHETA) ) 
      SINSQINV = 1.0_EXTRA_LONG_REAL / ( (1.0_EXTRA_LONG_REAL-COSTHETA) * (1.0_EXTRA_LONG_REAL + COSTHETA) )
      DO M = 0,MMAX
! Compute P_m^m
      PMM = 1.0_EXTRA_LONG_REAL
      NUM = 1
      DO J = 1, M
      PMM = PMM * SINTHETA * REAL(NUM, KIND = EXTRA_LONG_REAL) / SQRT( REAL( NUM*(NUM+1), KIND = EXTRA_LONG_REAL) )
      NUM = NUM + 2
      ENDDO
! renormalise to "fully normalised" functions
      PMM = PMM * SQRT( 0.5_EXTRA_LONG_REAL * REAL( 2 * M + 1, KIND = EXTRA_LONG_REAL) )
      
      IF(M .eq. LMAX) THEN
      INDEX = SIZE(Y,2)
      Y(I,INDEX) = PMM  !P_LMAX^LMAX
      EXIT !end of loop
      ENDIF
      L = M
      INDEX = M * LMAX +  (M * (3-M) ) /2 + 1 + (L - M)
      Y(I,INDEX) = PMM            
! Compute P_{m+1}^m
      PMM1 = COSTHETA * REAL( 2*M + 1, KIND = EXTRA_LONG_REAL) * PMM
! renormalise to "fully normalised" functions
      PMM1 = PMM1 * SQRT( REAL( 2 * M + 3, KIND = EXTRA_LONG_REAL) ) / REAL( 2*M+1, KIND = EXTRA_LONG_REAL)
      IF( M .eq. LMAX - 1) THEN
      INDEX = SIZE(Y,2)-1
      Y(I,INDEX) = PMM1 ! P_LMAX^LMAX-1
      CYCLE !next M
      ENDIF
        L = M + 1
        INDEX = M * LMAX +  (M * (3-M) ) /2 + 1 + (L - M)
        Y(I,INDEX) = PMM1 ! P_M+1^M
        DO L = M+2, LMAX
        INDEX = M * LMAX +  (M * (3-M) ) /2 + 1 + (L - M)
	FAC1 = REAL( (2 * L + 1) * (L-M) , KIND = EXTRA_LONG_REAL)  / REAL( (2*L-1)*(L+M), KIND = EXTRA_LONG_REAL)
	FAC1 = SQRT( FAC1 )
	FAC2 = REAL( (2 * L + 1) * (L-M) * (L-M-1) , KIND = EXTRA_LONG_REAL)  / REAL( (2*L-3)*(L+M)*(L+M-1), KIND = EXTRA_LONG_REAL)
	FAC2 = SQRT( FAC2 )
	Y(I,INDEX) = (FAC1 * COSTHETA * REAL( 2*L - 1, KIND = EXTRA_LONG_REAL) * Y(I,INDEX-1) - &
	FAC2 * REAL( L + M - 1, KIND = EXTRA_LONG_REAL) * Y(I,INDEX-2) ) / REAL( L - M, KIND = EXTRA_LONG_REAL)
	ENDDO

       ENDDO !M
      

! Compute derivatives:
      DO M = 0, MMAX
      DO L = M, LMAX
      INDEX = M * LMAX +  (M * (3-M) ) /2 + 1 + (L - M)
      IF( M .eq. L) THEN
      dY(I,INDEX) = REAL(L, KIND = EXTRA_LONG_REAL) * COSTHETA / SINTHETA * Y(I, INDEX )
      ELSE
      dY(I, INDEX) = REAL(L, KIND = EXTRA_LONG_REAL) * COSTHETA / SINTHETA * Y( I, INDEX ) - &
                    REAL(L+M ,KIND = EXTRA_LONG_REAL) * &
		    SQRT( REAL( (2*L+1)*(L-M), KIND = EXTRA_LONG_REAL) / REAL( (2*L-1) * (L+M), KIND= EXTRA_LONG_REAL) ) * &
		    Y( I, INDEX-1 ) / SINTHETA 
       ENDIF
       
		      
       ENDDO
       ENDDO
       
        ENDDO !I

  

 ! Renormalise so that the harmonics are Schmidt quasi-normalised.
 
      DO M = 0,MMAX
      DO L = M, LMAX
      INDEX = M * LMAX +  (M * (3-M) ) /2 + 1 + (L - M)
      IF( M .eq. 0) THEN
      FACTOR = SQRT(2.0_EXTRA_LONG_REAL/ REAL(2 * L + 1, KIND = EXTRA_LONG_REAL) )
      ELSE
      FACTOR = SQRT(4.0_EXTRA_LONG_REAL  / REAL(2 * L + 1, KIND = EXTRA_LONG_REAL) )
      ENDIF
      Y(:,INDEX) = Y(:,INDEX) * FACTOR
      DY(:,INDEX) = DY(:,INDEX) * FACTOR
      ENDDO
      ENDDO

 ! PRINT*, 'here', Y(1,9), COSTHETA_ARR(1), ACOS( COSTHETA_ARR(1))

  RETURN
END SUBROUTINE GET_LEGENDRE_FUNCTIONS

   SUBROUTINE EVALUATE_B_R_GRID( NTHETA_GRID, NPHI_GRID, GAUSS, HARMONICS, LMAX_B_OBS, LMAX, B_R, GRAD_H_B_R, ALF, DALF, ONE_DIV_SINTHETA )
! Evaluates B_r on the CMB on the defined (theta,phi) grid, along with its horizontal derivatives.
! Calculates the gradient of B_r assuming a radius of 1.

   IMPLICIT NONE
   INTEGER :: NTHETA_GRID, NPHI_GRID, LMAX, LMAX_B_OBS
   REAL( KIND = LONG_REAL) :: GAUSS(1:), B_R(1:,0:),  GRAD_H_B_R(1:,0:,1:), ALF(1:,1:), DALF(1:,1:), ONE_DIV_SINTHETA(1:)
   TYPE (HARMONIC_STRUCTURE) :: HARMONICS(1:)

   INTEGER :: I, INDEX_PLM, I_THETA, I_PHI

   REAL( KIND = LONG_REAL) :: PHI_DEP, DERV_PHI_DEP, PHI

   GRAD_H_B_R(:,:,:) = 0.0_LONG_REAL
   B_R(:,:) = 0.0_LONG_REAL

   DO I_THETA = 1, NTHETA_GRID
   DO I_PHI = 0, NPHI_GRID - 1
   PHI = I_PHI * 2.0_LONG_REAL * Pi / REAL(NPHI_GRID, KIND = LONG_REAL)

   DO I = 1, SIZE(HARMONICS)
   IF( HARMONICS(I)%L .GT. LMAX_B_OBS ) CYCLE

    IF( HARMONICS(I)%SINCOS .EQ. SINE_HARMONIC ) THEN
    PHI_DEP = SIN(  HARMONICS(I)%M * PHI  )
    DERV_PHI_DEP = HARMONICS(I)%M * COS(  HARMONICS(I)%M * PHI )
    ELSE
    PHI_DEP = COS(  HARMONICS(I)%M * PHI )
    DERV_PHI_DEP = -HARMONICS(I)%M * SIN(  HARMONICS(I)%M * PHI)
    ENDIF

    INDEX_PLM = HARMONICS(I)%M * LMAX +  (HARMONICS(I)%M * (3-HARMONICS(I)%M) ) /2 + 1 + (HARMONICS(I)%L - HARMONICS(I)%M)
    B_R( I_THETA, I_PHI ) = B_R( I_THETA, I_PHI )  + GAUSS(I) * (ES_RADIUS /CMB_RADIUS)**(HARMONICS(I)%L + 2) * (HARMONICS(I)%L + 1) * ALF(I_THETA, INDEX_PLM) * PHI_DEP
    GRAD_H_B_R( I_THETA, I_PHI, 1) = GRAD_H_B_R( I_THETA, I_PHI, 1) + GAUSS(I) *(ES_RADIUS /CMB_RADIUS)**(HARMONICS(I)%L + 2) * (HARMONICS(I)%L + 1) * DALF(I_THETA, INDEX_PLM) * PHI_DEP
    GRAD_H_B_R( I_THETA, I_PHI, 2) = GRAD_H_B_R( I_THETA, I_PHI, 2) + GAUSS(I) * (ES_RADIUS /CMB_RADIUS)**(HARMONICS(I)%L + 2) * (HARMONICS(I)%L + 1) * ALF(I_THETA, INDEX_PLM) * DERV_PHI_DEP * ONE_DIV_SINTHETA(I_THETA)
   ENDDO
   
   ENDDO
   ENDDO 
   RETURN
   END SUBROUTINE EVALUATE_B_R_GRID


    SUBROUTINE REAL_2_SPEC( REAL_SPACE, SPEC, LMAX, LMAX_TRANSFORM, HARMONICS, NPHI_GRID, NTHETA_GRID, LEGENDRE_INV )
! Projects a scalar quantity defined on a grid onto Schmidt quasi-normalised spherical harmonics

   IMPLICIT NONE
   INTEGER :: NTHETA_GRID, NPHI_GRID
   REAL( KIND = LONG_REAL) ::  REAL_SPACE(1:,0:), SPEC(1:), LEGENDRE_INV(1:,1:)
   TYPE (HARMONIC_STRUCTURE) :: HARMONICS(1:)

! Computes the spherical harmonic coefficients from Y_0^0 up to L,M = LMAX_TRANSFORM.

! LMAX is the maximum degree with which the array SPEC is defined. If LMAX_TRANSFORM < LMAX then the SPEC array is padded with zeros.
      
      REAL ( KIND = LONG_REAL) :: PHI_FAC
      INTEGER :: INDEX_PLM, I
      
      INTEGER :: LMAX, LMAX_TRANSFORM, MMAX, I_HARMONIC
     !  REAL_SPACE(:,:) = 1.0

    !   PRINT*, 'SLOW1', SUM( REAL_SPACE(1,:) ) / NPHI_GRID
! FFT     
      FFT_TRANSFORM_ARRAY(1:NTHETA_GRID,0:NPHI_GRID-1) = REAL_SPACE(:,:)
      CALL DFFTW_EXECUTE(PLAN_FFT_R2HC) 
      REAL_SPACE(:,:) = FFT_TRANSFORM_ARRAY(1:NTHETA_GRID,0:NPHI_GRID-1)    
     
      
      !PRINT*, 'FAST1', REAL_SPACE(1,0)

     ! PRINT*,  REAL_SPACE(:,1); PRINT*, REAL_SPACE(:,1) * 1.0_LONG_REAL * Pi / REAL( NPHI_GRID, KIND = LONG_REAL); STOP !; PRINT*, LEGENDRE_INV(1:NTHETA_GRID,19); PRINT*, SUM( REAL_SPACE(:,2) * LEGENDRE_INV(1:NTHETA_GRID,19)); STOP
! Legendre transform
       SPEC(:) = 0.0_LONG_REAL
       DO I =  1, LMAX_TRANSFORM * (LMAX_TRANSFORM + 2)
! Recall that 
! cos(m phi), m=1,2,3,4 is stored in the m^{th} element as 0.5
! sin(m phi), m=1,2,3,4 is stored in the (NPHI_GRID-m)^{th} element as -0.5    
! cos(0 phi)  is stored in the 0^{th} element as 1

      
      !PHI_FAC = 2.0_LONG_REAL * Pi / REAL( NPHI_GRID, KIND = LONG_REAL)
      !PHI_FAC = PHI_FAC / ( 4.0_LONG_REAL * Pi / REAL( 2 * HARMONICS(I)%L + 1, KIND = LONG_REAL ) )

       PHI_FAC = 0.5_LONG_REAL * REAL( 2 * HARMONICS(I)%L + 1, KIND = LONG_REAL) / REAL( NPHI_GRID, KIND = LONG_REAL) 

      INDEX_PLM = HARMONICS(I)%M * LMAX +  (HARMONICS(I)%M * (3-HARMONICS(I)%M) ) /2 + 1 + (HARMONICS(I)%L - HARMONICS(I)%M)

      IF( HARMONICS(I)%SINCOS .EQ. COSINE_HARMONIC) THEN
      SPEC( I ) = PHI_FAC  * SUM(  REAL_SPACE(1:NTHETA_GRID,HARMONICS(I)%M) * LEGENDRE_INV(1:NTHETA_GRID,INDEX_PLM) )
      ELSE
      SPEC( I ) = -PHI_FAC  * SUM(  REAL_SPACE(1:NTHETA_GRID,NPHI_GRID-HARMONICS(I)%M) * LEGENDRE_INV(1:NTHETA_GRID,INDEX_PLM) )
      ENDIF
       
     
      ENDDO
         		    
      RETURN
      END SUBROUTINE REAL_2_SPEC

SUBROUTINE REAL_2_SPEC_FIXED_M( REAL_SPACE, SPEC, LMAX, LMAX_TRANSFORM, HARMONICS, M, NTHETA_GRID, LEGENDRE_INV )
! Projects a scalar quantity defined on a grid onto Schmidt quasi-normalised spherical harmonics

IMPLICIT NONE
INTEGER :: NTHETA_GRID, NPHI_GRID, M
REAL( KIND = LONG_REAL) ::  REAL_SPACE(1:,0:), SPEC(1:), LEGENDRE_INV(1:,1:)
TYPE (HARMONIC_STRUCTURE) :: HARMONICS(1:)

! Computes the spherical harmonic coefficients from Y_0^0 up to L,M = LMAX_TRANSFORM.

! LMAX is the maximum degree with which the array SPEC is defined. If LMAX_TRANSFORM < LMAX then the SPEC array is padded with zeros.

REAL ( KIND = LONG_REAL) :: PHI_FAC
INTEGER :: INDEX_PLM, I

INTEGER :: LMAX, LMAX_TRANSFORM, I_HARMONIC
!  REAL_SPACE(:,:) = 1.0

!   PRINT*, 'SLOW1', SUM( REAL_SPACE(1,:) ) / NPHI_GRID
! FFT

! Legendre transform
SPEC(:) = 0.0_LONG_REAL
DO I =  1, LMAX_TRANSFORM * (LMAX_TRANSFORM + 2)
! Recall that
! cos(m phi), m=1,2,3,4 is stored in the m^{th} element as 0.5
! sin(m phi), m=1,2,3,4 is stored in the (NPHI_GRID-m)^{th} element as -0.5
! cos(0 phi)  is stored in the 0^{th} element as 1


!PHI_FAC = 2.0_LONG_REAL * Pi / REAL( NPHI_GRID, KIND = LONG_REAL)
!PHI_FAC = PHI_FAC / ( 4.0_LONG_REAL * Pi / REAL( 2 * HARMONICS(I)%L + 1, KIND = LONG_REAL ) )

PHI_FAC = 0.5_LONG_REAL * REAL( 2 * HARMONICS(I)%L + 1, KIND = LONG_REAL) / REAL( NPHI_GRID, KIND = LONG_REAL)

INDEX_PLM = HARMONICS(I)%M * LMAX +  (HARMONICS(I)%M * (3-HARMONICS(I)%M) ) /2 + 1 + (HARMONICS(I)%L - HARMONICS(I)%M)

IF( HARMONICS(I)%SINCOS .EQ. COSINE_HARMONIC) THEN
SPEC( I ) = PHI_FAC  * SUM(  REAL_SPACE(1:NTHETA_GRID,HARMONICS(I)%M) * LEGENDRE_INV(1:NTHETA_GRID,INDEX_PLM) )
ELSE
SPEC( I ) = -PHI_FAC  * SUM(  REAL_SPACE(1:NTHETA_GRID,NPHI_GRID-HARMONICS(I)%M) * LEGENDRE_INV(1:NTHETA_GRID,INDEX_PLM) )
ENDIF


ENDDO

RETURN
END SUBROUTINE REAL_2_SPEC_FIXED_M

SUBROUTINE WRITE_B_R_DOT (GAUSS_SV, GAUSS_DOT, GAUSS, LMAX_B, LMAX_SV, HARMONICS, MAX_SV_ES, MAX_B_DOT_ES )
IMPLICIT NONE
!  Units should be in nT/yr

REAL( KIND = LONG_REAL) :: GAUSS_DOT(:), GAUSS(:), GAUSS_SV(:),  MAX_SV_ES, MAX_B_DOT_ES
TYPE ( HARMONIC_STRUCTURE ) :: HARMONICS(1:)
INTEGER :: LMAX_SV, LMAX_B

REAL( KIND = LONG_REAL), ALLOCATABLE :: COSTHETA_GRID(:), ALF(:,:), DALF(:,:), ONE_DIV_SIN_THETA(:)
REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE :: TEMP_THETA_TRANSFORM_ALF(:,:), TEMP_THETA_TRANSFORM_DALF(:,:)
REAL( KIND = LONG_REAL) :: PHI,  PHI_DEP, DERV_PHI_DEP, B_DOT_CS, B_DOT_ES, B_CS, B_ES, SV_CS, SV_ES
INTEGER :: I_THETA, I_PHI, I_HARMONIC, INDEX_PLM, I


! setup grids
ALLOCATE( COSTHETA_GRID(1: NTHETA_GRID_CONTOUR_GMT))
DO I_THETA = 1, NTHETA_GRID_CONTOUR_GMT
COSTHETA_GRID(I_THETA) = COS(  I_THETA / REAL( NTHETA_GRID_CONTOUR_GMT + 1, KIND = LONG_REAL ) * Pi   )
ENDDO

ALLOCATE( TEMP_THETA_TRANSFORM_ALF(1: NTHETA_GRID_CONTOUR_GMT, (LMAX_SV + 1) * (LMAX_SV + 2)/2), TEMP_THETA_TRANSFORM_DALF(1: NTHETA_GRID_CONTOUR_GMT, (LMAX_SV + 1) * (LMAX_SV + 2)/2),ALF(1: NTHETA_GRID_CONTOUR_GMT, (LMAX_SV + 1) * (LMAX_SV + 2)/2), DALF(1: NTHETA_GRID_CONTOUR_GMT, (LMAX_SV + 1) * (LMAX_SV + 2)/2),  ONE_DIV_SIN_THETA(1: NTHETA_GRID_CONTOUR_GMT) )

CALL GET_LEGENDRE_FUNCTIONS( REAL(COSTHETA_GRID, KIND = EXTRA_LONG_REAL), LMAX_SV, LMAX_SV, TEMP_THETA_TRANSFORM_ALF, TEMP_THETA_TRANSFORM_DALF)
ALF = REAL(  TEMP_THETA_TRANSFORM_ALF, KIND = LONG_REAL)
DALF = REAL( TEMP_THETA_TRANSFORM_DALF, KIND = LONG_REAL)
ONE_DIV_SIN_THETA(:) = 1.0_LONG_REAL / SQRT( 1.0_LONG_REAL - COSTHETA_GRID(:)**2 )


OPEN(16, FILE = 'B_R_DOT_ES.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')
OPEN(17, FILE = 'B_R_DOT_CS.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')
OPEN(18, FILE = 'B_R_ES.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')
OPEN(19, FILE = 'B_R_CS.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')
OPEN(20, FILE = 'SV_R_ES.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')
OPEN(21, FILE = 'SV_R_CS.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')

MAX_SV_ES = -1.0
MAX_B_DOT_ES = -1.0

DO I_PHI = 0, NPHI_GRID_CONTOUR_GMT-1
DO I_THETA = 1, NTHETA_GRID_CONTOUR_GMT

!PHI =  I_PHI * 2.0_LONG_REAL * Pi / REAL(NPHI_GRID_CONTOUR_GMT, KIND = LONG_REAL)
PHI = -Pi + Pi /REAL(NPHI_GRID_CONTOUR_GMT, KIND = LONG_REAL) + 2.0 * Pi / REAL(NPHI_GRID_CONTOUR_GMT, KIND = LONG_REAL) * (I_PHI)

B_DOT_CS = 0.0_LONG_REAL
B_DOT_ES = 0.0_LONG_REAL
B_CS =  0.0_LONG_REAL
B_ES= 0.0_LONG_REAL
SV_CS = 0.0_8
SV_ES = 0.0_8

DO I = 1, LMAX_SV * (LMAX_SV + 2)
! evaluate B and B_dot at Earth surface
IF( HARMONICS(I)%SINCOS .EQ. SINE_HARMONIC ) THEN
PHI_DEP = SIN(  HARMONICS(I)%M * PHI )
DERV_PHI_DEP = HARMONICS(I)%M * COS(  HARMONICS(I)%M * PHI )
ELSE
PHI_DEP = COS(  HARMONICS(I)%M * PHI )
DERV_PHI_DEP = -HARMONICS(I)%M * SIN(  HARMONICS(I)%M * PHI)
ENDIF

INDEX_PLM = HARMONICS(I)%M * LMAX_SV +  (HARMONICS(I)%M * (3-HARMONICS(I)%M) ) /2 + 1 + (HARMONICS(I)%L - HARMONICS(I)%M)
B_DOT_ES = B_DOT_ES + GAUSS_DOT(I) * ALF(I_THETA, INDEX_PLM) * PHI_DEP * REAL(HARMONICS(I)%L + 1, KIND = LONG_REAL)
B_DOT_CS = B_DOT_CS + GAUSS_DOT(I) * ALF(I_THETA, INDEX_PLM) * PHI_DEP * REAL(HARMONICS(I)%L + 1, KIND = LONG_REAL) * (ES_RADIUS / CMB_RADIUS)**(HARMONICS(I)%L+2)
IF( HARMONICS(I)%L .LE. LMAX_B) THEN
B_CS = B_CS + GAUSS(I) * ALF(I_THETA, INDEX_PLM) * PHI_DEP *  REAL(HARMONICS(I)%L + 1, KIND = LONG_REAL) * (ES_RADIUS / CMB_RADIUS)**(HARMONICS(I)%L+2)
B_ES = B_ES + GAUSS(I) * ALF(I_THETA, INDEX_PLM) * PHI_DEP * REAL(HARMONICS(I)%L + 1, KIND = LONG_REAL)

SV_CS = SV_CS + GAUSS_SV(I) * ALF(I_THETA, INDEX_PLM) * PHI_DEP *  REAL(HARMONICS(I)%L + 1, KIND = LONG_REAL) * (ES_RADIUS / CMB_RADIUS)**(HARMONICS(I)%L+2)
SV_ES = SV_ES + GAUSS_SV(I) * ALF(I_THETA, INDEX_PLM) * PHI_DEP * REAL(HARMONICS(I)%L + 1, KIND = LONG_REAL)

ENDIF

ENDDO
WRITE(16,'(2F8.2,ES15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, B_DOT_ES
WRITE(17,'(2F8.2,ES15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, B_DOT_CS
WRITE(18,'(2F8.2,ES15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, B_ES
WRITE(19,'(2F8.2,ES15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, B_CS
WRITE(20,'(2F8.2,ES15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, SV_ES
WRITE(21,'(2F8.2,ES15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, SV_CS

IF( ABS(B_DOT_ES) > MAX_B_DOT_ES ) THEN
MAX_B_DOT_ES =  ABS(B_DOT_ES)
ENDIF

IF( ABS(SV_ES) > MAX_SV_ES ) THEN
MAX_SV_ES =  ABS(SV_ES)
ENDIF



ENDDO
ENDDO

!
CLOSE(16)
CLOSE(17)
CLOSE(18)
CLOSE(19)

RETURN
END SUBROUTINE WRITE_B_R_DOT

SUBROUTINE GET_FLOW(U_H,DIV_H_U_H, NTHETA, NPHI, M_MODES, FLOW_MODE, M_wave_max, FLOW_CONSTANTS, DELTA, RATIO, SINTHETA, COSTHETA , CHECK_SYMMETRY)
IMPLICIT NONE
REAL( KIND = 8) :: U_H(1:,0:,1:),DIV_H_U_H(1:,0:), FLOW_CONSTANTS(0:), DELTA, RATIO, SINTHETA(:), COSTHETA(:)
INTEGER :: NTHETA, NPHI, M_MODES(1:), M_wave_max, FLOW_MODE

INTEGER :: M_wave, I_PHI, I_THETA
REAL( KIND = 8) :: PHI
LOGICAL :: CHECK_SYMMETRY

U_H(:,:,:) = 0.0_8
DIV_H_U_H(:,:) = 0.0_8

IF( M_MODES(FLOW_MODE) .GE. 0) THEN !even mode, cos m phi dependence
M_wave = M_MODES(FLOW_MODE)

! test meridional flux constraint
IF (ABS( get_integral(1.0_8,M_wave,FLOW_CONSTANTS(M_wave),delta,RATIO)) > 1.0e-10) THEN
PRINT*, M_WAVE, 'FLUX CONSTRAINT NOT SATISFIED ', get_integral(1.0_8,M_wave,FLOW_CONSTANTS(M_wave),delta,RATIO)
STOP
ENDIF


DO I_PHI = 0, NPHI-1
PHI = I_PHI * 2.0_LONG_REAL * Pi / REAL(NPHI, KIND = LONG_REAL)
DO I_THETA = 1, NTHETA
! Construct flow at (theta,phi)
U_H(I_THETA, I_PHI,2) = (ABS(COSTHETA(I_THETA))  * exp(-(SINTHETA(I_THETA)-RATIO)**2/delta**2)  - FLOW_CONSTANTS(M_wave) )  * SINTHETA(I_THETA)**(M_wave+1) * COS(M_wave * PHI)

U_H(I_THETA, I_PHI,1) = -1.0_8 / SINTHETA(I_THETA) / ABS(COSTHETA(I_THETA)) * &
get_integral(SINTHETA(I_THETA),M_wave,FLOW_CONSTANTS(M_wave),delta,RATIO)  * &
(-M_wave * SIN(M_wave * PHI) ) / COSTHETA(I_THETA)

DIV_H_U_H(I_THETA, I_PHI) = -2.0_8 * get_integral(SINTHETA(I_THETA),M_wave,FLOW_CONSTANTS(M_wave),delta,RATIO) / ABS(COSTHETA( I_THETA)**3 ) &
* (-M_wave * SIN(M_wave * PHI))

ENDDO
ENDDO

ELSE !sin m phi dependence
M_WAVE = ABS(M_MODES(FLOW_MODE) ) !make sure the wavenumber is positive here...

! test meridional flux constraint
IF (ABS( get_integral(1.0_8,M_wave,FLOW_CONSTANTS(M_wave),delta,RATIO)) > 1.0e-10) THEN
PRINT*, M_WAVE, 'FLUX CONSTRAINT NOT SATISFIED ', get_integral(1.0_8,M_wave,FLOW_CONSTANTS(M_wave),delta,RATIO)
STOP
ENDIF


DO I_PHI = 0, NPHI-1
PHI = I_PHI * 2.0_LONG_REAL * Pi / REAL(NPHI, KIND = LONG_REAL)
DO I_THETA = 1, NTHETA

! Construct flow at (theta,phi)
U_H(I_THETA, I_PHI,2) = (ABS(COSTHETA(I_THETA)) * exp(-(SINTHETA(I_THETA)-RATIO)**2/delta**2)  - FLOW_CONSTANTS(M_wave) )  * SINTHETA(I_THETA)**(M_wave+1) * SIN(M_wave * PHI)

U_H(I_THETA, I_PHI,1) = -1.0_8 / SINTHETA(I_THETA) / ABS(COSTHETA(I_THETA)) * &
get_integral(SINTHETA(I_THETA),M_wave,FLOW_CONSTANTS(M_wave),delta,RATIO) * &
(M_wave * COS(M_wave * PHI) ) / COSTHETA(I_THETA)

DIV_H_U_H(I_THETA, I_PHI) = -2.0_8 * get_integral(SINTHETA(I_THETA),M_wave,FLOW_CONSTANTS(M_wave),delta,RATIO) / ABS(COSTHETA( I_THETA)**3) &
* (M_wave * COS(M_wave * PHI))

ENDDO
ENDDO
ENDIF

! check equatorial symmetry is correct
IF( NTHETA .GT. 10 .AND. CHECK_SYMMETRY) THEN
IF( ABS(U_H(4,1,1) + U_H(NTHETA-4+1,1,1)) .GT. 1e-10) PRINT*, 'MODE ', FLOW_MODE, ' HAS THETA COMPONENT THAT IS NOT E^A'
IF( ABS(U_H(4,1,2) - U_H(NTHETA-4+1,1,2)) .GT. 1e-10) PRINT*, 'MODE ', FLOW_MODE, ' HAS PHI COMPONENT THAT IS NOT E^S'
! PRINT*, M_MODES(FLOW_MODE),U_H(5,1,1), 1 * 2.0_LONG_REAL * Pi / REAL(NPHI_GRID, KIND = LONG_REAL), ACOS(COSTHETA_GRID(5)), FLOW_CONSTANTS(M_wave)
! PRINT*,M_MODES(FLOW_MODE),DIV_H_U_H(5,1)
ENDIF
END SUBROUTINE GET_FLOW

SUBROUTINE GET_FLOW_POLAR_VORTEX(U_H,DIV_H_U_H, NTHETA, NPHI, FLOW_MODE, RATIO, SINTHETA, COSTHETA , CHECK_SYMMETRY)
IMPLICIT NONE
REAL( KIND = 8) :: U_H(1:,0:,1:),DIV_H_U_H(1:,0:), RATIO, SINTHETA(:), COSTHETA(:)
INTEGER :: NTHETA, NPHI, FLOW_MODE

INTEGER :: I_PHI, I_THETA
REAL( KIND = 8) :: PHI
LOGICAL :: CHECK_SYMMETRY

U_H(:,:,:) = 0.0_8
DIV_H_U_H(:,:) = 0.0_8

IF(FLOW_MODE .LT. 0) THEN
PRINT*, 'FLOW MODE IS NOT 1 OR MORE'
STOP
ENDIF


DO I_PHI = 0, NPHI-1
PHI = I_PHI * 2.0_LONG_REAL * Pi / REAL(NPHI, KIND = LONG_REAL)
DO I_THETA = 1, NTHETA
! Construct flow at (theta,phi)
U_H(I_THETA, I_PHI,2) = SINTHETA(I_THETA)**(2*FLOW_MODE-1)

U_H(I_THETA, I_PHI,1) = 0.0_8

DIV_H_U_H(I_THETA, I_PHI) = 0.0_8

ENDDO
ENDDO


! check equatorial symmetry is correct
IF( NTHETA .GT. 10 .AND. CHECK_SYMMETRY) THEN
IF( ABS(U_H(4,1,1) + U_H(NTHETA-4+1,1,1)) .GT. 1e-10) PRINT*, 'MODE ', FLOW_MODE, ' HAS THETA COMPONENT THAT IS NOT E^A'
IF( ABS(U_H(4,1,2) - U_H(NTHETA-4+1,1,2)) .GT. 1e-10) PRINT*, 'MODE ', FLOW_MODE, ' HAS PHI COMPONENT THAT IS NOT E^S'
! PRINT*, M_MODES(FLOW_MODE),U_H(5,1,1), 1 * 2.0_LONG_REAL * Pi / REAL(NPHI_GRID, KIND = LONG_REAL), ACOS(COSTHETA_GRID(5)), FLOW_CONSTANTS(M_wave)
! PRINT*,M_MODES(FLOW_MODE),DIV_H_U_H(5,1)
ENDIF
END SUBROUTINE GET_FLOW_POLAR_VORTEX



SUBROUTINE FIND_OPT_FLOW( GAUSS, GAUSS_SV, NTHETA_LSQ, NTHETA_VIS, NPHI_VIS, NTHETA_GRID, M_wave_max, LMAX_OBS, LMAX_SV, MMAX_SV, LSQ, SV_SQ, FLOW_COEFFS, SV_OPT, FLOW, KE_SPEC, SV_OBS_VIS, LAT_max1, lat_min1, LAT_MIN2, LAT_MAX2, FILTER_SIGNAL, HARMONICS, DELTA, GAUSS_SYN, JUST_EVALUATE)

IMPLICIT NONE
REAL( KIND = 8), INTENT(IN) :: GAUSS(:),GAUSS_SV(:), LAT_max1, lat_min1, LAT_MIN2, LAT_MAX2, DELTA
REAL( KIND = 8), INTENT(OUT) :: SV_OPT(:,0:), FLOW(:,0:,:), LSQ, SV_SQ, SV_OBS_VIS(:,0:), GAUSS_SYN(:), KE_SPEC(:)
REAL( KIND = 8), INTENT(INOUT) :: FLOW_COEFFS(:)

INTEGER, INTENT(IN) :: NTHETA_LSQ, NTHETA_VIS, NPHI_VIS, NTHETA_GRID, M_wave_max, LMAX_SV, MMAX_SV, LMAX_OBS, FILTER_SIGNAL
TYPE (HARMONIC_STRUCTURE), INTENT(IN) :: HARMONICS(:)

REAL( KIND = 8) :: VALUE(2), PHI, SPECTRAL_COEFF, THETA, C, VAL1,VAL0, AREA
REAL( KIND = 8), ALLOCATABLE ::  LEGENDRE_GAUW_TRANSFORM(:), COSTHETA_GRID_TRANSFORM(:),  GAUSS_DOT(:,:), SV_STRUCTURES(:,:,:,:), MAT(:,:), RHS(:), SV_OBS(:,:), NOT_NEEDED(:,:,:), SV_OPT_CALC(:,:)
INTEGER :: NP, I, J, L, M, M_wave, I_THETA, I_PHI,  NUM_LEGENDRE_SV, IOS, HARMONIC, SINCOS, INDEX_PLM,  SV_MODE,  MAX_I_THETA, MAX_I_PHI, NPHI_GRID
INTEGER, ALLOCATABLE :: IPIV(:), M_MODES(:)

REAL( KIND = 8), ALLOCATABLE :: GRAD_H_B_R(:,:,:), B_R(:,:), ALF_TRANSFORM(:,:), DALF_TRANSFORM(:,:), B_R_DOT(:,:), SPEC(:), LEGENDRE_INV_TRANSFORM(:,:), ONE_DIV_SIN_THETA_TRANSFORM(:), U_COEFFS(:), U_H(:,:,:), BR_L_SPEC(:), BR_M_SPEC(:),  SIN_THETA_TRANSFORM(:), DIV_H_U_H(:,:), FLOW_CONSTANTS(:)

REAL( KIND = 8), ALLOCATABLE ::  COSTHETA_GRID_VIS(:), SINTHETA_GRID_VIS(:), ALF_VIS(:,:), DALF_VIS(:,:), ALF_LSQ_LOWER(:,:), ALF_LSQ_UPPER(:,:), DALF_LSQ_LOWER(:,:), DALF_LSQ_UPPER(:,:), &
COSTHETA_GRID_LSQ_CANONICAL(:), LEGENDRE_GAUW_LSQ_CANONICAL(:), COSTHETA_GRID_LSQ_UPPER(:), COSTHETA_GRID_LSQ_LOWER(:), &
LEGENDRE_GAUW_LSQ_UPPER(:), LEGENDRE_GAUW_LSQ_LOWER(:), ONE_DIV_SIN_THETA_LSQ_UPPER(:), ONE_DIV_SIN_THETA_LSQ_LOWER(:), &
SIN_THETA_LSQ_UPPER(:), SIN_THETA_LSQ_LOWER(:), ONE_DIV_SIN_THETA_VIS(:), SIN_THETA_VIS(:)

LOGICAL :: CHECK_SYMMETRY, JUST_EVALUATE

REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE, DIMENSION(:,:)  ::  TEMP_DALF, TEMP_ALF

INTEGER :: INFO

! Finds the optimal flow. If JUST_EVALUATE is true, then it just uses the input FLOW coefficients.


! Assemble M-modes for flow
ALLOCATE( M_MODES(1: 2 * M_wave_max + 1) )
M_MODES(1) = 0
DO I = 2, M_wave_max+1   ! Positive M means cosine
M_MODES(I) = I - 1
M_MODES(I+M_wave_max) = - (I-1)  !Negative M means sine
ENDDO


! PRINT*, 'CALCULATING SV ON SPATIAL GRID'
! Grid needed for phi-transforms: AND LSQ INTEGRATION...
! Although we need to evaluate the LSQ fit of curl(uxB) to SV, the terms involved are
! The squares of the synthetic SV, the cross terms, and the squares of the observed SV.
NPHI_GRID = MAX( M_wave_max + LMAX_OBS + MMAX_SV+1, 2 * (M_wave_max+LMAX_OBS)+1, 2*MMAX_SV+1 )
!   PRINT*, 'USING ', NPHI_GRID, ' PTS IN LONGITUDE'

NUM_LEGENDRE_SV = MMAX_SV * LMAX_SV +  (MMAX_SV * (3-MMAX_SV) ) /2 + 1 + (LMAX_SV - MMAX_SV)


! Get the Associated Legendre Functions (ALF) on the LSQ grid
ALLOCATE(   COSTHETA_GRID_LSQ_CANONICAL(NTHETA_LSQ), LEGENDRE_GAUW_LSQ_CANONICAL(NTHETA_LSQ) )
CALL GAUWTS ( NTHETA_LSQ, COSTHETA_GRID_LSQ_CANONICAL, LEGENDRE_GAUW_LSQ_CANONICAL )
ALLOCATE( COSTHETA_GRID_LSQ_UPPER(NTHETA_LSQ), COSTHETA_GRID_LSQ_LOWER(NTHETA_LSQ), LEGENDRE_GAUW_LSQ_UPPER(NTHETA_LSQ), &
LEGENDRE_GAUW_LSQ_LOWER(NTHETA_LSQ), SIN_THETA_LSQ_UPPER(NTHETA_LSQ), SIN_THETA_LSQ_LOWER(NTHETA_LSQ), ONE_DIV_SIN_THETA_LSQ_UPPER(NTHETA_LSQ), ONE_DIV_SIN_THETA_LSQ_LOWER(NTHETA_LSQ))

! translate canonical interval [-1,1] to [COS(90-LAT_MAX1), COS(90-LAT_MIN1)] and for LatMIN/MAX 2
COSTHETA_GRID_LSQ_UPPER (:) = (COS(Pi/180.0_8 * (90.0_8-LAT_MAX1)) + COS(Pi/180.0_8 * (90.0_8-LAT_MIN1)))/2.0_8 + &
(COS(Pi/180.0_8 * (90.0_8-LAT_MAX1)) - COS(Pi/180.0_8 * (90.0_8-LAT_MIN1)))/2.0_8 * &
COSTHETA_GRID_LSQ_CANONICAL(:)

COSTHETA_GRID_LSQ_LOWER (:) = (COS(Pi/180.0_8 * (90.0_8-LAT_MAX2)) + COS(Pi/180.0_8 * (90.0_8-LAT_MIN2)))/2.0_8 + &
(COS(Pi/180.0_8 * (90.0_8-LAT_MAX2)) - COS(Pi/180.0_8 * (90.0_8-LAT_MIN2)))/2.0_8 * &
COSTHETA_GRID_LSQ_CANONICAL(:)

SIN_THETA_LSQ_UPPER = SQRT(1.0_8 - COSTHETA_GRID_LSQ_UPPER(:)**2)
ONE_DIV_SIN_THETA_LSQ_UPPER = 1.0_8 / SIN_THETA_LSQ_UPPER


SIN_THETA_LSQ_LOWER = SQRT(1.0_8 - COSTHETA_GRID_LSQ_LOWER(:)**2)
ONE_DIV_SIN_THETA_LSQ_LOWER = 1.0_8 / SIN_THETA_LSQ_LOWER
!PRINT*, (COS(Pi/180.0_8 * (90.0_8-LAT_MAX1)) - COS(Pi/180.0_8 * (90.0_8-LAT_MIN1)))/2.0_8
LEGENDRE_GAUW_LSQ_UPPER(:) = (COS(Pi/180.0_8 * (90.0_8-LAT_MAX1)) - COS(Pi/180.0_8 * (90.0_8-LAT_MIN1)))/2.0_8 *&
LEGENDRE_GAUW_LSQ_CANONICAL(:)

LEGENDRE_GAUW_LSQ_LOWER(:) = (COS(Pi/180.0_8 * (90.0_8-LAT_MAX2)) - COS(Pi/180.0_8 * (90.0_8-LAT_MIN2)))/2.0_8 *&
LEGENDRE_GAUW_LSQ_CANONICAL(:)

ALLOCATE( TEMP_DALF(NTHETA_LSQ, NUM_LEGENDRE_SV), TEMP_ALF(NTHETA_LSQ, NUM_LEGENDRE_SV) )
ALLOCATE( ALF_LSQ_UPPER(NTHETA_LSQ, NUM_LEGENDRE_SV), DALF_LSQ_UPPER(NTHETA_LSQ, NUM_LEGENDRE_SV) )
ALLOCATE( ALF_LSQ_LOWER(NTHETA_LSQ, NUM_LEGENDRE_SV), DALF_LSQ_LOWER(NTHETA_LSQ, NUM_LEGENDRE_SV) )

CALL GET_LEGENDRE_FUNCTIONS( REAL(COSTHETA_GRID_LSQ_UPPER, KIND = EXTRA_LONG_REAL), LMAX_SV, MMAX_SV, TEMP_ALF, TEMP_DALF)
ALF_LSQ_UPPER = REAL(  TEMP_ALF, KIND = 8)
DALF_LSQ_UPPER = REAL( TEMP_DALF, KIND = 8)


CALL GET_LEGENDRE_FUNCTIONS( REAL(COSTHETA_GRID_LSQ_LOWER, KIND = EXTRA_LONG_REAL), LMAX_SV, MMAX_SV, TEMP_ALF, TEMP_DALF)
ALF_LSQ_LOWER = REAL(  TEMP_ALF, KIND = 8)
DALF_LSQ_LOWER = REAL( TEMP_DALF, KIND = 8)

DEALLOCATE( TEMP_ALF, TEMP_DALF)

ALLOCATE( SV_STRUCTURES(1:NTHETA_LSQ, 0:NPHI_GRID-1,1:2 * M_wave_max+1,1:2) )  !last index is lat region.
ALLOCATE (FLOW_CONSTANTS(0:M_wave_max) )


! Get return-flow constants:
do m = 0, M_wave_max
c = 1.0_8
VAL1 = get_integral(1.0_8,m,c,delta,ICB_CMB_RATIO)
c = 0.0_8
VAL0 = get_integral(1.0_8,m,c,delta,ICB_CMB_RATIO)
!    PRINT*, VAL0, VAL1
! Now exploit that dependence (in c) is linear
FLOW_CONSTANTS(m) = -VAL0 / (VAL1 - VAL0)
!PRINT*, FLOW_CONSTANTS(m)
ENDDO
!STOP
ALLOCATE( NOT_NEEDED(1:NTHETA_LSQ,0:NPHI_GRID-1,2) )

IF( FILTER_SIGNAL .EQ. 0) THEN !Don't filter SV

ALLOCATE( U_H(1:NTHETA_LSQ, 0:NPHI_GRID-1,1:2), DIV_H_U_H(1:NTHETA_LSQ, 0:NPHI_GRID-1) )

! Evaluate B_r and its horizontal derivative on LSQ grid (theta, phi) grid
ALLOCATE( B_R_DOT(NTHETA_LSQ, 0:NPHI_GRID-1) )
ALLOCATE( B_R(1:NTHETA_LSQ, 0:NPHI_GRID-1), GRAD_H_B_R(1:NTHETA_LSQ,0:NPHI_GRID-1,2) )


DO SV_MODE = 1, 2 * M_wave_max + 1

CALL EVALUATE_B_R_GRID( NTHETA_LSQ, NPHI_GRID, GAUSS, HARMONICS, LMAX_OBS, LMAX_SV, B_R, GRAD_H_B_R, &
ALF_LSQ_UPPER, DALF_LSQ_UPPER, ONE_DIV_SIN_THETA_LSQ_UPPER )

CHECK_SYMMETRY = .FALSE.
CALL GET_FLOW(U_H,DIV_H_U_H,NTHETA_LSQ, NPHI_GRID, M_MODES, SV_MODE, M_wave_max, FLOW_CONSTANTS, DELTA, ICB_CMB_RATIO, SIN_THETA_LSQ_UPPER, COSTHETA_GRID_LSQ_UPPER, CHECK_SYMMETRY )
!PRINT*, ACOS( COSTHETA_GRID_LSQ_UPPER(3)), 2.0_8 * Pi * 1 / NPHI_GRID, B_R(3,1), U_H(3,1,1:2),

!Assemble SV:
DO I_THETA = 1, NTHETA_LSQ
DO I_PHI = 0, NPHI_GRID-1
B_R_DOT(I_THETA, I_PHI) = - U_H(I_THETA, I_PHI,1) * GRAD_H_B_R(I_THETA, I_PHI,1) - U_H(I_THETA, I_PHI,2) * GRAD_H_B_R(I_THETA, I_PHI,2) - B_R(I_THETA, I_PHI) * DIV_H_U_H(I_THETA, I_PHI)
ENDDO
ENDDO
SV_STRUCTURES(:,:,SV_MODE,1) = B_R_DOT(:,:) * 3600.0_8 * 24.0_8 * 365.0_8 / CMB_RADIUS

!PRINT*, ACOS( COSTHETA_GRID_LSQ_UPPER(3)), 2.0_8 * Pi * 1 / NPHI_GRID, B_R(3,1)
!PRINT*, SV_STRUCTURES(3,1,SV_MODE,1)

CALL EVALUATE_B_R_GRID( NTHETA_LSQ, NPHI_GRID, GAUSS, HARMONICS, LMAX_OBS, LMAX_SV, B_R, GRAD_H_B_R, &
ALF_LSQ_LOWER, DALF_LSQ_LOWER, ONE_DIV_SIN_THETA_LSQ_LOWER )

CALL GET_FLOW(U_H,DIV_H_U_H,NTHETA_LSQ, NPHI_GRID, M_MODES, SV_MODE, M_wave_max, FLOW_CONSTANTS, DELTA, ICB_CMB_RATIO, SIN_THETA_LSQ_LOWER, COSTHETA_GRID_LSQ_LOWER, CHECK_SYMMETRY )
!Assemble SV:
DO I_THETA = 1, NTHETA_LSQ
DO I_PHI = 0, NPHI_GRID-1
B_R_DOT(I_THETA, I_PHI) = - U_H(I_THETA, I_PHI,1) * GRAD_H_B_R(I_THETA, I_PHI,1) - U_H(I_THETA, I_PHI,2) * GRAD_H_B_R(I_THETA, I_PHI,2) - B_R(I_THETA, I_PHI) * DIV_H_U_H(I_THETA, I_PHI)
ENDDO
ENDDO
SV_STRUCTURES(:,:,SV_MODE,2) = B_R_DOT(:,:) * 3600.0_8 * 24.0_8 * 365.0_8 / CMB_RADIUS

ENDDO

!PRINT*, GRAD_H_B_R(3,1,1:2)

ELSE  ! Perform a spherical harmonic filter


ALLOCATE( GAUSS_DOT(1:LMAX_SV * (LMAX_SV+2),2*M_wave_max+1))

ALLOCATE( FFT_TRANSFORM_ARRAY(1:NTHETA_GRID,0:NPHI_GRID-1) )

! FFTs in PHI, REAL to Half complex
CALL DFFTW_PLAN_MANY_R2R(PLAN_FFT_R2HC,       &  ! PLAN
1,                                            &  ! Rank of transforms
NPHI_GRID,                                    &  ! size of each transform
NTHETA_GRID,                                  &  ! how many
FFT_TRANSFORM_ARRAY,                          &  ! Input array
SIZE(FFT_TRANSFORM_ARRAY),                    &  ! subset size of transform (whole set)
NTHETA_GRID,                                  &  ! Stride for transform
1,                                            &  ! Gap between transforms in array
FFT_TRANSFORM_ARRAY,                          &  ! Output array
SIZE(FFT_TRANSFORM_ARRAY),                    &  ! subset size of output array
NTHETA_GRID,                                  &  ! output stride
1,                                            &  ! Gap between outputs for transforms.
FFTW_R2HC, TRANSFORM_OPTIMISATION)                        ! Transform type; flags


ALLOCATE(   COSTHETA_GRID_TRANSFORM(NTHETA_GRID), LEGENDRE_GAUW_TRANSFORM(NTHETA_GRID), &
ALF_TRANSFORM(NTHETA_GRID, NUM_LEGENDRE_SV), DALF_TRANSFORM(NTHETA_GRID, NUM_LEGENDRE_SV), &
TEMP_DALF(NTHETA_GRID, NUM_LEGENDRE_SV), TEMP_ALF(NTHETA_GRID, NUM_LEGENDRE_SV), LEGENDRE_INV_TRANSFORM(NTHETA_GRID, NUM_LEGENDRE_SV) , &
ONE_DIV_SIN_THETA_TRANSFORM(1:NTHETA_GRID), SIN_THETA_TRANSFORM(1:NTHETA_GRID)  )


CALL GAUWTS ( NTHETA_GRID, COSTHETA_GRID_TRANSFORM, LEGENDRE_GAUW_TRANSFORM )

! Get the Associated Legendre Functions (ALF) at the theta grid points, with their theta derivatives (DALF), of the ALF's up to degree LMAX_SV
CALL GET_LEGENDRE_FUNCTIONS( REAL(COSTHETA_GRID_TRANSFORM, KIND = EXTRA_LONG_REAL), LMAX_SV, MMAX_SV, TEMP_ALF, TEMP_DALF)
ALF_TRANSFORM = REAL(  TEMP_ALF, KIND = 8)
DALF_TRANSFORM = REAL( TEMP_DALF, KIND = 8)
ONE_DIV_SIN_THETA_TRANSFORM(:) = 1.0_LONG_REAL / SQRT( 1.0_LONG_REAL - COSTHETA_GRID_TRANSFORM(:)**2 )
SIN_THETA_TRANSFORM(:) = SQRT( 1.0_LONG_REAL - COSTHETA_GRID_TRANSFORM(:)**2 )

DO I = 1, NUM_LEGENDRE_SV
LEGENDRE_INV_TRANSFORM(1:NTHETA_GRID,I) = ALF_TRANSFORM(1:NTHETA_GRID,I) * LEGENDRE_GAUW_TRANSFORM(1:NTHETA_GRID)
ENDDO
DEALLOCATE( TEMP_ALF, TEMP_DALF)



ALLOCATE( U_H(1:NTHETA_GRID, 0:NPHI_GRID-1,1:2), DIV_H_U_H(1:NTHETA_GRID, 0:NPHI_GRID-1) )

! Evaluate B_r and its horizontal derivative on transform grid (theta, phi) grid
ALLOCATE( B_R_DOT(NTHETA_GRID, 0:NPHI_GRID-1), SPEC(1:LMAX_SV * (LMAX_SV + 2)) )
ALLOCATE( B_R(1:NTHETA_GRID, 0:NPHI_GRID-1), GRAD_H_B_R(1:NTHETA_GRID,0:NPHI_GRID-1,2) )

CALL EVALUATE_B_R_GRID( NTHETA_GRID, NPHI_GRID, GAUSS, HARMONICS, LMAX_OBS, LMAX_SV, B_R, GRAD_H_B_R, ALF_TRANSFORM, DALF_TRANSFORM, ONE_DIV_SIN_THETA_TRANSFORM )



DO SV_MODE = 1, 2 * M_wave_max + 1
CHECK_SYMMETRY = .TRUE.
CALL GET_FLOW(U_H,DIV_H_U_H,NTHETA_GRID, NPHI_GRID, M_MODES, SV_MODE, M_wave_max, FLOW_CONSTANTS, DELTA, ICB_CMB_RATIO, SIN_THETA_TRANSFORM, COSTHETA_GRID_TRANSFORM, CHECK_SYMMETRY )

!Assemble SV:
DO I_THETA = 1, NTHETA_GRID
DO I_PHI = 0, NPHI_GRID-1
B_R_DOT(I_THETA, I_PHI) = - U_H(I_THETA, I_PHI,1) * GRAD_H_B_R(I_THETA, I_PHI,1) - U_H(I_THETA, I_PHI,2) * GRAD_H_B_R(I_THETA, I_PHI,2) - B_R(I_THETA, I_PHI) * DIV_H_U_H(I_THETA, I_PHI)
ENDDO
ENDDO

! Transform
CALL REAL_2_SPEC( B_R_DOT, SPEC, LMAX_SV, LMAX_SV, HARMONICS, NPHI_GRID, NTHETA_GRID , LEGENDRE_INV_TRANSFORM )

! The array SPEC contains the spherical harmonic transform of B_R^DOT.



! Evaluate Gauss coefficients for B_r_dot in nT/yr
DO I = 1, LMAX_SV * (LMAX_SV+2)
GAUSS_DOT(I,SV_MODE) = SPEC(I) * (CMB_RADIUS/ES_RADIUS)**(HARMONICS(I)%L + 2) / REAL( HARMONICS(I)%L + 1, KIND = 8)
ENDDO

! Dimensionalise to nT/yr given a flow in m/s (and scale to the core)
GAUSS_DOT(:,SV_MODE) = GAUSS_DOT(:,SV_MODE) * 3600.0_8 * 24.0_8 * 365.0_8 / CMB_RADIUS

! Re-evaluate on grid



CALL EVALUATE_B_R_GRID( NTHETA_LSQ, NPHI_GRID, GAUSS_DOT(:,SV_MODE), HARMONICS, LMAX_SV, LMAX_SV, SV_STRUCTURES(:,:,SV_MODE,1), NOT_NEEDED, &
ALF_LSQ_UPPER, DALF_LSQ_UPPER, ONE_DIV_SIN_THETA_LSQ_UPPER )
CALL EVALUATE_B_R_GRID( NTHETA_LSQ, NPHI_GRID, GAUSS_DOT(:,SV_MODE), HARMONICS, LMAX_SV, LMAX_SV, SV_STRUCTURES(:,:,SV_MODE,2), NOT_NEEDED, &
ALF_LSQ_LOWER, DALF_LSQ_LOWER, ONE_DIV_SIN_THETA_LSQ_LOWER )


ENDDO !SV MODE

CALL DFFTW_DESTROY_PLAN(PLAN_FFT_R2HC)
DEALLOCATE(FFT_TRANSFORM_ARRAY)

ENDIF


!PRINT*, 'Setting up matrix system'

ALLOCATE( MAT(1:2*M_wave_max+1,1:2*M_wave_max+1) , RHS(1:2*M_wave_max+1) )

DO I = 1, 2*M_wave_max+1
DO J = 1, 2*M_wave_max+1

Mat(I,J) = 0.0_8
DO I_THETA = 1, NTHETA_LSQ
DO I_PHI = 0, NPHI_GRID-1
Mat(I,J) = Mat(I,J) + SV_STRUCTURES(I_THETA, I_PHI,I,1) * SV_STRUCTURES(I_THETA, I_PHI,J,1) * LEGENDRE_GAUW_LSQ_UPPER(I_THETA)
ENDDO
ENDDO

DO I_THETA = 1, NTHETA_LSQ
DO I_PHI = 0, NPHI_GRID-1
Mat(I,J) = Mat(I,J) + SV_STRUCTURES(I_THETA, I_PHI,I,2) * SV_STRUCTURES(I_THETA, I_PHI,J,2) * LEGENDRE_GAUW_LSQ_LOWER(I_THETA)
ENDDO
ENDDO

Mat(I,J) = Mat(I,J) * 2.0_8 * Pi / REAL( NPHI_GRID, KIND = 8)

ENDDO
ENDDO


! Setup RHS
ALLOCATE( SV_OBS(1:NTHETA_LSQ, 0:NPHI_GRID-1), IPIV(1:2* M_wave_max+1) )
CALL EVALUATE_B_R_GRID( NTHETA_LSQ, NPHI_GRID, GAUSS_SV, HARMONICS, LMAX_SV, LMAX_SV, SV_OBS, NOT_NEEDED, ALF_LSQ_UPPER, DALF_LSQ_UPPER, ONE_DIV_SIN_THETA_LSQ_UPPER )

DO I = 1, 2*M_wave_max+1
RHS(I) = 0.0_8
DO I_THETA = 1, NTHETA_LSQ
DO I_PHI = 0, NPHI_GRID-1
RHS(I) = RHS(I) + SV_OBS(I_THETA, I_PHI) * SV_STRUCTURES(I_THETA, I_PHI,I,1) * LEGENDRE_GAUW_LSQ_UPPER(I_THETA)
ENDDO
ENDDO

ENDDO !I

CALL EVALUATE_B_R_GRID( NTHETA_LSQ, NPHI_GRID, GAUSS_SV, HARMONICS, LMAX_SV, LMAX_SV, SV_OBS, NOT_NEEDED, ALF_LSQ_LOWER, DALF_LSQ_LOWER, ONE_DIV_SIN_THETA_LSQ_LOWER )

DO I = 1, 2*M_wave_max+1
DO I_THETA = 1, NTHETA_LSQ
DO I_PHI = 0, NPHI_GRID-1
RHS(I) = RHS(I) + SV_OBS(I_THETA, I_PHI) * SV_STRUCTURES(I_THETA, I_PHI,I,2) * LEGENDRE_GAUW_LSQ_LOWER(I_THETA)
ENDDO
ENDDO

ENDDO !I


RHS(:) = RHS(:) * 2.0_8 * Pi / REAL( NPHI_GRID, KIND = 8)


!PRINT*, RHS
!PRINT*, MAT

!!WRITE(13,'(ES)') Mat
!WRITE(14,'(ES)') RHS


!PRINT*, 'WRITING PLOTTING DATA...'
!CALL WRITE_B_R_DOT(GAUSS_SV, GAUSS_DOT, GAUSS, LMAX_B_OBS, LMAX_SV, HARMONICS , MAX_SV_ES, MAX_B_DOT_ES)
!
!PRINT*, 'SCALED FLOW CAN HAVE UP TO MAX VALUE OF', AMPLITUDE * (MAX_SV_ES/MAX_B_DOT_ES),' m/s'


CALL DGETRF( 2 * M_wave_max+1, 2 * M_wave_max+1,  Mat, 2 * M_wave_max+1, IPIV, INFO)
IF( INFO .NE. 0) THEN
PRINT*, 'DGETRF FAILED, INFO ', INFO
STOP
ENDIF
CALL DGETRS('N', 2 * M_wave_max+1, 1, Mat, 2 * M_wave_max+1, IPIV, RHS, 2 * M_wave_max+1, INFO )

IF( INFO .NE. 0) THEN
PRINT*, 'DGETRS FAILED, INFO ', INFO
STOP
ENDIF

!PRINT*, 'OPTIMAL SOLUTION: M, AMPLITUDE (M>=0 IS COSINE, M<0 IS SINE) '
!DO I = 1, 2 * M_wave_max+1
!PRINT*, M_MODES(I), RHS(I)
!ENDDO

IF( .NOT. JUST_EVALUATE ) THEN
FLOW_COEFFS = RHS
ENDIF

! Find least squares value:

ALLOCATE( SV_OPT_CALC(1:NTHETA_LSQ,0:NPHI_GRID-1))

DO I_THETA = 1, NTHETA_LSQ
DO I_PHI = 0, NPHI_GRID-1
SV_OPT_CALC(I_THETA,I_PHI) = SUM( FLOW_COEFFS(:) * SV_STRUCTURES(I_THETA,I_PHI,:,1))
ENDDO
ENDDO
CALL EVALUATE_B_R_GRID( NTHETA_LSQ, NPHI_GRID, GAUSS_SV, HARMONICS, LMAX_SV, LMAX_SV, SV_OBS, NOT_NEEDED, ALF_LSQ_UPPER, DALF_LSQ_UPPER, ONE_DIV_SIN_THETA_LSQ_UPPER )
LSQ = 0.0_8
SV_SQ = 0.0_8
DO I_PHI = 0, NPHI_GRID - 1
LSQ = LSQ + SUM( (SV_OBS(:,I_PHI) - SV_OPT_CALC(:,I_PHI))**2 * LEGENDRE_GAUW_LSQ_UPPER(:) )
SV_SQ = SV_SQ + SUM( (SV_OBS(:,I_PHI))**2 * LEGENDRE_GAUW_LSQ_UPPER(:) )
ENDDO

DO I_THETA = 1, NTHETA_LSQ
DO I_PHI = 0, NPHI_GRID-1
SV_OPT_CALC(I_THETA,I_PHI) = SUM( FLOW_COEFFS(:) * SV_STRUCTURES(I_THETA,I_PHI,:,2))
ENDDO
ENDDO
CALL EVALUATE_B_R_GRID( NTHETA_LSQ, NPHI_GRID, GAUSS_SV, HARMONICS, LMAX_SV, LMAX_SV, SV_OBS, NOT_NEEDED, ALF_LSQ_LOWER, DALF_LSQ_LOWER, ONE_DIV_SIN_THETA_LSQ_LOWER )
DO I_PHI = 0, NPHI_GRID - 1
LSQ = LSQ + SUM( (SV_OBS(:,I_PHI) - SV_OPT_CALC(:,I_PHI))**2 * LEGENDRE_GAUW_LSQ_LOWER(:) )
SV_SQ = SV_SQ + SUM( (SV_OBS(:,I_PHI))**2 * LEGENDRE_GAUW_LSQ_LOWER(:) )
ENDDO
LSQ = LSQ * 2.0_8 * Pi / REAL( NPHI_GRID, KIND = 8)
SV_SQ = SV_SQ * 2.0_8 * Pi / REAL( NPHI_GRID, KIND = 8)
DEALLOCATE( SV_OPT_CALC )
!WRITE(6,'(A,ES12.4,A)') 'LEAST SQUARES DEVIATION \int (SV - SV_syn)^2 sin(theta) dtheta dphi = ', LSQ, ' (nT/yr)^2'


! Find flow spectrum in terms of rms per wavenumber
IF(ALLOCATED(U_H)) DEALLOCATE(U_H)
IF(ALLOCATED(DIV_H_U_H)) DEALLOCATE( DIV_H_U_H)

ALLOCATE( U_H(1:NTHETA_LSQ,0:NPHI_GRID-1,1:2), DIV_H_U_H(1:NTHETA_LSQ,0:NPHI_GRID-1) )

KE_SPEC(:) = 0.0_8
! Find the flow
DO SV_MODE = 1, 2 * M_wave_max + 1
U_H(:,:,:) = 0.0_8
DIV_H_U_H(:,:) = 0.0_8

CHECK_SYMMETRY = .FALSE.
CALL GET_FLOW(U_H,DIV_H_U_H,NTHETA_LSQ, NPHI_GRID, M_MODES, SV_MODE, M_wave_max, FLOW_CONSTANTS, DELTA, ICB_CMB_RATIO, SIN_THETA_LSQ_UPPER, COSTHETA_GRID_LSQ_UPPER, CHECK_SYMMETRY )
!Assemble flow for single mode:
U_H = U_H * RHS(SV_MODE)
DO I_PHI = 0, NPHI_GRID - 1
KE_SPEC(SV_MODE) = KE_SPEC(SV_MODE) + SUM( (U_H(:,I_PHI,1)**2 + U_H(:,I_PHI,2)**2)  * LEGENDRE_GAUW_LSQ_UPPER(:) )
ENDDO

CALL GET_FLOW(U_H,DIV_H_U_H,NTHETA_LSQ, NPHI_GRID, M_MODES, SV_MODE, M_wave_max, FLOW_CONSTANTS, DELTA, ICB_CMB_RATIO, SIN_THETA_LSQ_LOWER, COSTHETA_GRID_LSQ_LOWER, CHECK_SYMMETRY )
!Assemble flow for single mode:
U_H = U_H * RHS(SV_MODE)
DO I_PHI = 0, NPHI_GRID - 1
KE_SPEC(SV_MODE) = KE_SPEC(SV_MODE) + SUM( (U_H(:,I_PHI,1)**2 + U_H(:,I_PHI,2)**2)  * LEGENDRE_GAUW_LSQ_LOWER(:) )
ENDDO

ENDDO
KE_SPEC = KE_SPEC * 2.0_8 * Pi / REAL( NPHI_GRID, KIND = 8)

! rescale in terms of (km/yr)^2:
KE_SPEC = KE_SPEC  * ( 3600.0_8 * 24.0_8 * 365.0_8 / 1000.0_8)**2

! Calculate the area by integrating 1 over the region
AREA = ( SUM( LEGENDRE_GAUW_LSQ_LOWER ) + SUM ( LEGENDRE_GAUW_LSQ_UPPER ) ) * 2.0 * Pi

KE_SPEC = KE_SPEC / AREA


! *******
! Visualise SV on VIS grid
!ALLOCATE( SV_OPT(1:NTHETA_VIS, 0:NPHI_VIS-1))
DEALLOCATE( U_H, DIV_H_U_H, B_R, B_R_DOT, GRAD_H_B_R)

ALLOCATE( U_H(1:NTHETA_VIS, 0:NPHI_VIS-1,1:2), DIV_H_U_H(1:NTHETA_VIS, 0:NPHI_VIS-1) )

! Evaluate B_r and its horizontal derivative on VIS grid (theta, phi) grid
ALLOCATE( B_R_DOT(NTHETA_VIS, 0:NPHI_VIS-1) )
ALLOCATE( B_R(1:NTHETA_VIS, 0:NPHI_VIS-1), GRAD_H_B_R(1:NTHETA_VIS,0:NPHI_VIS-1,2) )


ALLOCATE( TEMP_DALF(NTHETA_VIS, NUM_LEGENDRE_SV), TEMP_ALF(NTHETA_VIS, NUM_LEGENDRE_SV), COSTHETA_GRID_VIS(1:NTHETA_VIS), SIN_THETA_VIS(1:NTHETA_VIS), ONE_DIV_SIN_THETA_VIS(1:NTHETA_VIS) )
ALLOCATE( ALF_VIS(NTHETA_VIS, NUM_LEGENDRE_SV), DALF_VIS(NTHETA_VIS, NUM_LEGENDRE_SV) )
DO I = 1, NTHETA_VIS
COSTHETA_GRID_VIS(I) = COS( I * Pi / REAL( NTHETA_VIS+1, KIND = 8) )
ENDDO

CALL GET_LEGENDRE_FUNCTIONS( REAL(COSTHETA_GRID_VIS, KIND = EXTRA_LONG_REAL), LMAX_SV, MMAX_SV, TEMP_ALF, TEMP_DALF)
ALF_VIS = REAL(  TEMP_ALF, KIND = 8)
DALF_VIS = REAL( TEMP_DALF, KIND = 8)

SIN_THETA_VIS(:) = SQRT( 1.0_LONG_REAL - COSTHETA_GRID_VIS(:)**2 )
ONE_DIV_SIN_THETA_VIS(:) = 1.0_LONG_REAL / SIN_THETA_VIS(:)

! Evaluate SV_OBS on this grid:
CALL EVALUATE_B_R_GRID( NTHETA_VIS, NPHI_VIS, GAUSS_SV, HARMONICS, LMAX_SV, LMAX_SV, SV_OBS_VIS, GRAD_H_B_R, ALF_VIS, DALF_VIS, ONE_DIV_SIN_THETA_VIS )

IF( FILTER_SIGNAL .EQ. 1) THEN ! can re-use filtered Gauss coefficients here
SV_OPT(:,:) = 0.0_8
DO SV_MODE = 1, 2*M_wave_max+1
CALL EVALUATE_B_R_GRID( NTHETA_VIS, NPHI_VIS, GAUSS_DOT(:,SV_MODE), HARMONICS, LMAX_SV, LMAX_SV, B_R_DOT, GRAD_H_B_R, &
ALF_VIS, DALF_VIS, ONE_DIV_SIN_THETA_VIS )
SV_OPT = SV_OPT + FLOW_COEFFS(SV_MODE) * B_R_DOT(:,:)
ENDDO

ELSE

CALL EVALUATE_B_R_GRID( NTHETA_VIS, NPHI_VIS, GAUSS, HARMONICS, LMAX_OBS, LMAX_SV, B_R, GRAD_H_B_R, &
ALF_VIS, DALF_VIS, ONE_DIV_SIN_THETA_VIS )


B_R_DOT(:,:) = 0.0_8
DO SV_MODE = 1, 2 * M_wave_max + 1
CHECK_SYMMETRY = .TRUE.
CALL GET_FLOW(U_H,DIV_H_U_H,NTHETA_VIS, NPHI_VIS, M_MODES, SV_MODE, M_wave_max, FLOW_CONSTANTS, DELTA, ICB_CMB_RATIO, SIN_THETA_VIS, COSTHETA_GRID_VIS, CHECK_SYMMETRY )
!Assemble SV:
DO I_THETA = 1, NTHETA_VIS
DO I_PHI = 0, NPHI_VIS-1
B_R_DOT(I_THETA, I_PHI) = B_R_DOT(I_THETA, I_PHI) + FLOW_COEFFS(SV_MODE) * (-U_H(I_THETA, I_PHI,1) * GRAD_H_B_R(I_THETA, I_PHI,1) - &
U_H(I_THETA, I_PHI,2) * GRAD_H_B_R(I_THETA, I_PHI,2) - B_R(I_THETA, I_PHI) * DIV_H_U_H(I_THETA, I_PHI) )
ENDDO
ENDDO
ENDDO
SV_OPT = B_R_DOT(:,:) * 3600.0_8 * 24.0_8 * 365.0_8 / CMB_RADIUS
ENDIF

!ALLOCATE( FLOW(1:NTHETA_VIS,0:NPHI_VIS-1,1:2))
! Find the flow
FLOW(:,:,:) = 0.0_8
DO SV_MODE = 1, 2 * M_wave_max + 1
CHECK_SYMMETRY = .TRUE.
CALL GET_FLOW(U_H,DIV_H_U_H,NTHETA_VIS, NPHI_VIS, M_MODES, SV_MODE, M_wave_max, FLOW_CONSTANTS, DELTA, ICB_CMB_RATIO, SIN_THETA_VIS, COSTHETA_GRID_VIS, CHECK_SYMMETRY )
!Assemble SV:
DO I_THETA = 1, NTHETA_VIS
DO I_PHI = 0, NPHI_VIS-1
FLOW(I_THETA,I_PHI,1:2) = FLOW(I_THETA,I_PHI,1:2) + FLOW_COEFFS(SV_MODE) * U_H(I_THETA, I_PHI,1:2)
ENDDO
ENDDO
ENDDO
FLOW = FLOW / 1000.0_8 * 3600.0_8 * 24.0_8 * 365.0_8

IF( FILTER_SIGNAL .EQ. 1) THEN
! return Gauss coefficients of SV
DO I = 1, LMAX_SV * (LMAX_SV + 2)
GAUSS_SYN(I) = SUM( GAUSS_DOT(I,:) * FLOW_COEFFS(:) )
ENDDO
ENDIF

RETURN
END SUBROUTINE FIND_OPT_FLOW


SUBROUTINE CALC_SV_AZIMUTHAL_ONLY( GAUSS, NTHETA_GRID, M_wave_max, LMAX_OBS, LMAX_SV, MMAX_SV, FLOW_COEFFS, FILTER_SIGNAL, HARMONICS, DELTA, GAUSS_SYN, FLOW_SOLID_BODY)

! calculates the SV due to a flow (assumed azimuthal only)

IMPLICIT NONE
REAL( KIND = 8), INTENT(IN) :: GAUSS(:), DELTA
REAL( KIND = 8), INTENT(OUT) :: GAUSS_SYN(:)
REAL( KIND = 8), INTENT(IN) :: FLOW_COEFFS(:)

INTEGER, INTENT(IN) :: NTHETA_GRID, M_wave_max, LMAX_SV, MMAX_SV, LMAX_OBS, FILTER_SIGNAL
TYPE (HARMONIC_STRUCTURE), INTENT(IN) :: HARMONICS(:)

REAL( KIND = 8), ALLOCATABLE ::  LEGENDRE_GAUW_TRANSFORM(:), COSTHETA_GRID_TRANSFORM(:),  GAUSS_DOT(:,:), SV_STRUCTURES(:,:,:,:), MAT(:,:), RHS(:), SV_OBS(:,:), NOT_NEEDED(:,:,:), SV_OPT_CALC(:,:)
INTEGER :: NP, I, J, L, M, M_wave, I_THETA, I_PHI,  NUM_LEGENDRE_SV, IOS, HARMONIC, SINCOS, INDEX_PLM,  SV_MODE,  MAX_I_THETA, MAX_I_PHI, NPHI_GRID
INTEGER, ALLOCATABLE :: IPIV(:), M_MODES(:)

REAL( KIND = 8), ALLOCATABLE :: GRAD_H_B_R(:,:,:), B_R(:,:), ALF_TRANSFORM(:,:), DALF_TRANSFORM(:,:), B_R_DOT(:,:), SPEC(:), LEGENDRE_INV_TRANSFORM(:,:), ONE_DIV_SIN_THETA_TRANSFORM(:), U_COEFFS(:), U_H(:,:,:), BR_L_SPEC(:), BR_M_SPEC(:),  SIN_THETA_TRANSFORM(:), DIV_H_U_H(:,:), FLOW_CONSTANTS(:)

REAL( KIND = 8) :: C, VAL0, VAL1, FLOW_SOLID_BODY

REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE, DIMENSION(:,:)  ::  TEMP_DALF, TEMP_ALF
LOGICAL :: CHECK_SYMMETRY
INTEGER :: INFO

! Assemble M-modes for flow
ALLOCATE( M_MODES(1: 2 * M_wave_max + 1) )
M_MODES(1) = 0
DO I = 2, M_wave_max+1   ! Positive M means cosine
M_MODES(I) = I - 1
M_MODES(I+M_wave_max) = - (I-1)  !Negative M means sine
ENDDO


! PRINT*, 'CALCULATING SV ON SPATIAL GRID'
! Grid needed for phi-transforms: AND LSQ INTEGRATION...
! Although we need to evaluate the LSQ fit of curl(uxB) to SV, the terms involved are
! The squares of the synthetic SV, the cross terms, and the squares of the observed SV.
NPHI_GRID = MAX( M_wave_max + LMAX_OBS + MMAX_SV+1, 2 * (M_wave_max+LMAX_OBS)+1, 2*MMAX_SV+1 )
!   PRINT*, 'USING ', NPHI_GRID, ' PTS IN LONGITUDE'

NUM_LEGENDRE_SV = MMAX_SV * LMAX_SV +  (MMAX_SV * (3-MMAX_SV) ) /2 + 1 + (LMAX_SV - MMAX_SV)


ALLOCATE (FLOW_CONSTANTS(0:M_wave_max) )


! Get return-flow constants:
do m = 0, M_wave_max
c = 1.0_8
VAL1 = get_integral(1.0_8,m,c,delta,ICB_CMB_RATIO)
c = 0.0_8
VAL0 = get_integral(1.0_8,m,c,delta,ICB_CMB_RATIO)
!    PRINT*, VAL0, VAL1
! Now exploit that dependence (in c) is linear
FLOW_CONSTANTS(m) = -VAL0 / (VAL1 - VAL0)
!PRINT*, FLOW_CONSTANTS(m)
ENDDO
!STOP

ALLOCATE( GAUSS_DOT(1:LMAX_SV * (LMAX_SV+2),2*M_wave_max+1))

ALLOCATE( FFT_TRANSFORM_ARRAY(1:NTHETA_GRID,0:NPHI_GRID-1) )

! FFTs in PHI, REAL to Half complex
CALL DFFTW_PLAN_MANY_R2R(PLAN_FFT_R2HC,       &  ! PLAN
1,                                            &  ! Rank of transforms
NPHI_GRID,                                    &  ! size of each transform
NTHETA_GRID,                                  &  ! how many
FFT_TRANSFORM_ARRAY,                          &  ! Input array
SIZE(FFT_TRANSFORM_ARRAY),                    &  ! subset size of transform (whole set)
NTHETA_GRID,                                  &  ! Stride for transform
1,                                            &  ! Gap between transforms in array
FFT_TRANSFORM_ARRAY,                          &  ! Output array
SIZE(FFT_TRANSFORM_ARRAY),                    &  ! subset size of output array
NTHETA_GRID,                                  &  ! output stride
1,                                            &  ! Gap between outputs for transforms.
FFTW_R2HC, TRANSFORM_OPTIMISATION)                        ! Transform type; flags


ALLOCATE(   COSTHETA_GRID_TRANSFORM(NTHETA_GRID), LEGENDRE_GAUW_TRANSFORM(NTHETA_GRID), &
ALF_TRANSFORM(NTHETA_GRID, NUM_LEGENDRE_SV), DALF_TRANSFORM(NTHETA_GRID, NUM_LEGENDRE_SV), &
TEMP_DALF(NTHETA_GRID, NUM_LEGENDRE_SV), TEMP_ALF(NTHETA_GRID, NUM_LEGENDRE_SV), LEGENDRE_INV_TRANSFORM(NTHETA_GRID, NUM_LEGENDRE_SV) , &
ONE_DIV_SIN_THETA_TRANSFORM(1:NTHETA_GRID), SIN_THETA_TRANSFORM(1:NTHETA_GRID)  )


CALL GAUWTS ( NTHETA_GRID, COSTHETA_GRID_TRANSFORM, LEGENDRE_GAUW_TRANSFORM )

! Get the Associated Legendre Functions (ALF) at the theta grid points, with their theta derivatives (DALF), of the ALF's up to degree LMAX_SV
CALL GET_LEGENDRE_FUNCTIONS( REAL(COSTHETA_GRID_TRANSFORM, KIND = EXTRA_LONG_REAL), LMAX_SV, MMAX_SV, TEMP_ALF, TEMP_DALF)
ALF_TRANSFORM = REAL(  TEMP_ALF, KIND = 8)
DALF_TRANSFORM = REAL( TEMP_DALF, KIND = 8)
ONE_DIV_SIN_THETA_TRANSFORM(:) = 1.0_LONG_REAL / SQRT( 1.0_LONG_REAL - COSTHETA_GRID_TRANSFORM(:)**2 )
SIN_THETA_TRANSFORM(:) = SQRT( 1.0_LONG_REAL - COSTHETA_GRID_TRANSFORM(:)**2 )

DO I = 1, NUM_LEGENDRE_SV
LEGENDRE_INV_TRANSFORM(1:NTHETA_GRID,I) = ALF_TRANSFORM(1:NTHETA_GRID,I) * LEGENDRE_GAUW_TRANSFORM(1:NTHETA_GRID)
ENDDO
DEALLOCATE( TEMP_ALF, TEMP_DALF)



ALLOCATE( U_H(1:NTHETA_GRID, 0:NPHI_GRID-1,1:2), DIV_H_U_H(1:NTHETA_GRID, 0:NPHI_GRID-1) )

! Evaluate B_r and its horizontal derivative on transform grid (theta, phi) grid
ALLOCATE( B_R_DOT(NTHETA_GRID, 0:NPHI_GRID-1), SPEC(1:LMAX_SV * (LMAX_SV + 2)) )
ALLOCATE( B_R(1:NTHETA_GRID, 0:NPHI_GRID-1), GRAD_H_B_R(1:NTHETA_GRID,0:NPHI_GRID-1,2) )

CALL EVALUATE_B_R_GRID( NTHETA_GRID, NPHI_GRID, GAUSS, HARMONICS, LMAX_OBS, LMAX_SV, B_R, GRAD_H_B_R, ALF_TRANSFORM, DALF_TRANSFORM, ONE_DIV_SIN_THETA_TRANSFORM )
B_R_DOT(:,:) = 0.0_8

IF( FLOW_SOLID_BODY < 0.0_8) THEN
DO I_THETA = 1, NTHETA_GRID
DO I_PHI = 0, NPHI_GRID-1
B_R_DOT(I_THETA, I_PHI) = B_R_DOT(I_THETA, I_PHI) - FLOW_SOLID_BODY * SIN_THETA_TRANSFORM(I_THETA) / (1221.0_8/3480.0_8) * GRAD_H_B_R(I_THETA, I_PHI,2)
ENDDO
ENDDO

ELSE
DO SV_MODE = 1, 2 * M_wave_max + 1
CHECK_SYMMETRY = .TRUE.
CALL GET_FLOW(U_H,DIV_H_U_H,NTHETA_GRID, NPHI_GRID, M_MODES, SV_MODE, M_wave_max, FLOW_CONSTANTS, DELTA, ICB_CMB_RATIO, SIN_THETA_TRANSFORM, COSTHETA_GRID_TRANSFORM, CHECK_SYMMETRY )


!Assemble SV:
DO I_THETA = 1, NTHETA_GRID
DO I_PHI = 0, NPHI_GRID-1

B_R_DOT(I_THETA, I_PHI) = B_R_DOT(I_THETA, I_PHI) - FLOW_COEFFS(SV_MODE) * U_H(I_THETA, I_PHI,2) * GRAD_H_B_R(I_THETA, I_PHI,2)

ENDDO
ENDDO
ENDDO

ENDIF



! Transform
CALL REAL_2_SPEC( B_R_DOT, SPEC, LMAX_SV, LMAX_SV, HARMONICS, NPHI_GRID, NTHETA_GRID , LEGENDRE_INV_TRANSFORM )

! The array SPEC contains the spherical harmonic transform of B_R^DOT.


! Evaluate Gauss coefficients for B_r_dot in nT/yr
DO I = 1, LMAX_SV * (LMAX_SV+2)
GAUSS_SYN(I) = SPEC(I) * (CMB_RADIUS/ES_RADIUS)**(HARMONICS(I)%L + 2) / REAL( HARMONICS(I)%L + 1, KIND = 8)
ENDDO

! Dimensionalise to nT/yr given a flow in m/s (and scale to the core)
GAUSS_SYN(:) = GAUSS_SYN(:) * 3600.0_8 * 24.0_8 * 365.0_8 / CMB_RADIUS


CALL DFFTW_DESTROY_PLAN(PLAN_FFT_R2HC)
DEALLOCATE(FFT_TRANSFORM_ARRAY)


RETURN
END SUBROUTINE CALC_SV_AZIMUTHAL_ONLY


SUBROUTINE FIND_OPT_FLOW_MASKED( GAUSS, GAUSS_SV, NTHETA_LSQ, NTHETA_VIS, NPHI_VIS, NTHETA_GRID, M_wave_max, LMAX_OBS, LMAX_SV, MMAX_SV, LSQ, SV_SQ, FLOW_COEFFS, SV_OPT, FLOW, KE_SPEC, SV_OBS_VIS, LAT_max1, lat_min1, LAT_MIN2, LAT_MAX2, FILTER_SIGNAL, HARMONICS, DELTA, GAUSS_SYN, JUST_EVALUATE)

! Same as FIND_OPT_FLOW but masks the flow to have only a nonzero component within the latitude bounds specified.
! This flow is therefore not strictly geophysical, but produces a localised SV.

IMPLICIT NONE
REAL( KIND = 8), INTENT(IN) :: GAUSS(:),GAUSS_SV(:), LAT_max1, lat_min1, LAT_MIN2, LAT_MAX2, DELTA
REAL( KIND = 8), INTENT(OUT) :: SV_OPT(:,0:), FLOW(:,0:,:), LSQ, SV_SQ, SV_OBS_VIS(:,0:), GAUSS_SYN(:), KE_SPEC(:)
REAL( KIND = 8), INTENT(INOUT) :: FLOW_COEFFS(:)

INTEGER, INTENT(IN) :: NTHETA_LSQ, NTHETA_VIS, NPHI_VIS, NTHETA_GRID, M_wave_max, LMAX_SV, MMAX_SV, LMAX_OBS, FILTER_SIGNAL
TYPE (HARMONIC_STRUCTURE), INTENT(IN) :: HARMONICS(:)

REAL( KIND = 8) :: VALUE(2), PHI, SPECTRAL_COEFF, THETA, C, VAL1,VAL0, AREA
REAL( KIND = 8), ALLOCATABLE ::  LEGENDRE_GAUW_TRANSFORM(:), COSTHETA_GRID_TRANSFORM(:),  GAUSS_DOT(:,:), SV_STRUCTURES(:,:,:,:), MAT(:,:), RHS(:), SV_OBS(:,:), NOT_NEEDED(:,:,:), SV_OPT_CALC(:,:)
INTEGER :: NP, I, J, L, M, M_wave, I_THETA, I_PHI,  NUM_LEGENDRE_SV, IOS, HARMONIC, SINCOS, INDEX_PLM,  SV_MODE,  MAX_I_THETA, MAX_I_PHI, NPHI_GRID
INTEGER, ALLOCATABLE :: IPIV(:), M_MODES(:)

REAL( KIND = 8), ALLOCATABLE :: GRAD_H_B_R(:,:,:), B_R(:,:), ALF_TRANSFORM(:,:), DALF_TRANSFORM(:,:), B_R_DOT(:,:), SPEC(:), LEGENDRE_INV_TRANSFORM(:,:), ONE_DIV_SIN_THETA_TRANSFORM(:), U_COEFFS(:), U_H(:,:,:), BR_L_SPEC(:), BR_M_SPEC(:),  SIN_THETA_TRANSFORM(:), DIV_H_U_H(:,:), FLOW_CONSTANTS(:)

REAL( KIND = 8), ALLOCATABLE ::  COSTHETA_GRID_VIS(:), SINTHETA_GRID_VIS(:), ALF_VIS(:,:), DALF_VIS(:,:), ALF_LSQ_LOWER(:,:), ALF_LSQ_UPPER(:,:), DALF_LSQ_LOWER(:,:), DALF_LSQ_UPPER(:,:), &
COSTHETA_GRID_LSQ_CANONICAL(:), LEGENDRE_GAUW_LSQ_CANONICAL(:), COSTHETA_GRID_LSQ_UPPER(:), COSTHETA_GRID_LSQ_LOWER(:), &
LEGENDRE_GAUW_LSQ_UPPER(:), LEGENDRE_GAUW_LSQ_LOWER(:), ONE_DIV_SIN_THETA_LSQ_UPPER(:), ONE_DIV_SIN_THETA_LSQ_LOWER(:), &
SIN_THETA_LSQ_UPPER(:), SIN_THETA_LSQ_LOWER(:), ONE_DIV_SIN_THETA_VIS(:), SIN_THETA_VIS(:)

LOGICAL :: CHECK_SYMMETRY, JUST_EVALUATE

REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE, DIMENSION(:,:)  ::  TEMP_DALF, TEMP_ALF

INTEGER :: INFO

! Finds the optimal flow. If JUST_EVALUATE is true, then it just uses the input FLOW coefficients.


! Assemble M-modes for flow
ALLOCATE( M_MODES(1: 2 * M_wave_max + 1) )
M_MODES(1) = 0
DO I = 2, M_wave_max+1   ! Positive M means cosine
M_MODES(I) = I - 1
M_MODES(I+M_wave_max) = - (I-1)  !Negative M means sine
ENDDO


! PRINT*, 'CALCULATING SV ON SPATIAL GRID'
! Grid needed for phi-transforms: AND LSQ INTEGRATION...
! Although we need to evaluate the LSQ fit of curl(uxB) to SV, the terms involved are
! The squares of the synthetic SV, the cross terms, and the squares of the observed SV.
NPHI_GRID = MAX( M_wave_max + LMAX_OBS + MMAX_SV+1, 2 * (M_wave_max+LMAX_OBS)+1, 2*MMAX_SV+1 )
!   PRINT*, 'USING ', NPHI_GRID, ' PTS IN LONGITUDE'

NUM_LEGENDRE_SV = MMAX_SV * LMAX_SV +  (MMAX_SV * (3-MMAX_SV) ) /2 + 1 + (LMAX_SV - MMAX_SV)


! Get the Associated Legendre Functions (ALF) on the LSQ grid
ALLOCATE(   COSTHETA_GRID_LSQ_CANONICAL(NTHETA_LSQ), LEGENDRE_GAUW_LSQ_CANONICAL(NTHETA_LSQ) )
CALL GAUWTS ( NTHETA_LSQ, COSTHETA_GRID_LSQ_CANONICAL, LEGENDRE_GAUW_LSQ_CANONICAL )
ALLOCATE( COSTHETA_GRID_LSQ_UPPER(NTHETA_LSQ), COSTHETA_GRID_LSQ_LOWER(NTHETA_LSQ), LEGENDRE_GAUW_LSQ_UPPER(NTHETA_LSQ), &
LEGENDRE_GAUW_LSQ_LOWER(NTHETA_LSQ), SIN_THETA_LSQ_UPPER(NTHETA_LSQ), SIN_THETA_LSQ_LOWER(NTHETA_LSQ), ONE_DIV_SIN_THETA_LSQ_UPPER(NTHETA_LSQ), ONE_DIV_SIN_THETA_LSQ_LOWER(NTHETA_LSQ))

! translate canonical interval [-1,1] to [COS(90-LAT_MAX1), COS(90-LAT_MIN1)] and for LatMIN/MAX 2
COSTHETA_GRID_LSQ_UPPER (:) = (COS(Pi/180.0_8 * (90.0_8-LAT_MAX1)) + COS(Pi/180.0_8 * (90.0_8-LAT_MIN1)))/2.0_8 + &
(COS(Pi/180.0_8 * (90.0_8-LAT_MAX1)) - COS(Pi/180.0_8 * (90.0_8-LAT_MIN1)))/2.0_8 * &
COSTHETA_GRID_LSQ_CANONICAL(:)

COSTHETA_GRID_LSQ_LOWER (:) = (COS(Pi/180.0_8 * (90.0_8-LAT_MAX2)) + COS(Pi/180.0_8 * (90.0_8-LAT_MIN2)))/2.0_8 + &
(COS(Pi/180.0_8 * (90.0_8-LAT_MAX2)) - COS(Pi/180.0_8 * (90.0_8-LAT_MIN2)))/2.0_8 * &
COSTHETA_GRID_LSQ_CANONICAL(:)

SIN_THETA_LSQ_UPPER = SQRT(1.0_8 - COSTHETA_GRID_LSQ_UPPER(:)**2)
ONE_DIV_SIN_THETA_LSQ_UPPER = 1.0_8 / SIN_THETA_LSQ_UPPER


SIN_THETA_LSQ_LOWER = SQRT(1.0_8 - COSTHETA_GRID_LSQ_LOWER(:)**2)
ONE_DIV_SIN_THETA_LSQ_LOWER = 1.0_8 / SIN_THETA_LSQ_LOWER
!PRINT*, (COS(Pi/180.0_8 * (90.0_8-LAT_MAX1)) - COS(Pi/180.0_8 * (90.0_8-LAT_MIN1)))/2.0_8
LEGENDRE_GAUW_LSQ_UPPER(:) = (COS(Pi/180.0_8 * (90.0_8-LAT_MAX1)) - COS(Pi/180.0_8 * (90.0_8-LAT_MIN1)))/2.0_8 *&
LEGENDRE_GAUW_LSQ_CANONICAL(:)

LEGENDRE_GAUW_LSQ_LOWER(:) = (COS(Pi/180.0_8 * (90.0_8-LAT_MAX2)) - COS(Pi/180.0_8 * (90.0_8-LAT_MIN2)))/2.0_8 *&
LEGENDRE_GAUW_LSQ_CANONICAL(:)

ALLOCATE( TEMP_DALF(NTHETA_LSQ, NUM_LEGENDRE_SV), TEMP_ALF(NTHETA_LSQ, NUM_LEGENDRE_SV) )
ALLOCATE( ALF_LSQ_UPPER(NTHETA_LSQ, NUM_LEGENDRE_SV), DALF_LSQ_UPPER(NTHETA_LSQ, NUM_LEGENDRE_SV) )
ALLOCATE( ALF_LSQ_LOWER(NTHETA_LSQ, NUM_LEGENDRE_SV), DALF_LSQ_LOWER(NTHETA_LSQ, NUM_LEGENDRE_SV) )

CALL GET_LEGENDRE_FUNCTIONS( REAL(COSTHETA_GRID_LSQ_UPPER, KIND = EXTRA_LONG_REAL), LMAX_SV, MMAX_SV, TEMP_ALF, TEMP_DALF)
ALF_LSQ_UPPER = REAL(  TEMP_ALF, KIND = 8)
DALF_LSQ_UPPER = REAL( TEMP_DALF, KIND = 8)


CALL GET_LEGENDRE_FUNCTIONS( REAL(COSTHETA_GRID_LSQ_LOWER, KIND = EXTRA_LONG_REAL), LMAX_SV, MMAX_SV, TEMP_ALF, TEMP_DALF)
ALF_LSQ_LOWER = REAL(  TEMP_ALF, KIND = 8)
DALF_LSQ_LOWER = REAL( TEMP_DALF, KIND = 8)

DEALLOCATE( TEMP_ALF, TEMP_DALF)

ALLOCATE( SV_STRUCTURES(1:NTHETA_LSQ, 0:NPHI_GRID-1,1:2 * M_wave_max+1,1:2) )  !last index is lat region.
ALLOCATE (FLOW_CONSTANTS(0:M_wave_max) )


! Get return-flow constants:
do m = 0, M_wave_max
c = 1.0_8
VAL1 = get_integral(1.0_8,m,c,delta,ICB_CMB_RATIO)
c = 0.0_8
VAL0 = get_integral(1.0_8,m,c,delta,ICB_CMB_RATIO)
!    PRINT*, VAL0, VAL1
! Now exploit that dependence (in c) is linear
FLOW_CONSTANTS(m) = -VAL0 / (VAL1 - VAL0)
!PRINT*, FLOW_CONSTANTS(m)
ENDDO
!STOP
ALLOCATE( NOT_NEEDED(1:NTHETA_LSQ,0:NPHI_GRID-1,2) )

IF( FILTER_SIGNAL .EQ. 0) THEN !Don't filter SV

ALLOCATE( U_H(1:NTHETA_LSQ, 0:NPHI_GRID-1,1:2), DIV_H_U_H(1:NTHETA_LSQ, 0:NPHI_GRID-1) )

! Evaluate B_r and its horizontal derivative on LSQ grid (theta, phi) grid
ALLOCATE( B_R_DOT(NTHETA_LSQ, 0:NPHI_GRID-1) )
ALLOCATE( B_R(1:NTHETA_LSQ, 0:NPHI_GRID-1), GRAD_H_B_R(1:NTHETA_LSQ,0:NPHI_GRID-1,2) )


DO SV_MODE = 1, 2 * M_wave_max + 1

CALL EVALUATE_B_R_GRID( NTHETA_LSQ, NPHI_GRID, GAUSS, HARMONICS, LMAX_OBS, LMAX_SV, B_R, GRAD_H_B_R, &
ALF_LSQ_UPPER, DALF_LSQ_UPPER, ONE_DIV_SIN_THETA_LSQ_UPPER )

CHECK_SYMMETRY = .FALSE.
CALL GET_FLOW(U_H,DIV_H_U_H,NTHETA_LSQ, NPHI_GRID, M_MODES, SV_MODE, M_wave_max, FLOW_CONSTANTS, DELTA, ICB_CMB_RATIO, SIN_THETA_LSQ_UPPER, COSTHETA_GRID_LSQ_UPPER, CHECK_SYMMETRY )
!PRINT*, ACOS( COSTHETA_GRID_LSQ_UPPER(3)), 2.0_8 * Pi * 1 / NPHI_GRID, B_R(3,1), U_H(3,1,1:2),

!Assemble SV:
DO I_THETA = 1, NTHETA_LSQ
DO I_PHI = 0, NPHI_GRID-1
B_R_DOT(I_THETA, I_PHI) = - U_H(I_THETA, I_PHI,1) * GRAD_H_B_R(I_THETA, I_PHI,1) - U_H(I_THETA, I_PHI,2) * GRAD_H_B_R(I_THETA, I_PHI,2) - B_R(I_THETA, I_PHI) * DIV_H_U_H(I_THETA, I_PHI)
ENDDO
ENDDO
SV_STRUCTURES(:,:,SV_MODE,1) = B_R_DOT(:,:) * 3600.0_8 * 24.0_8 * 365.0_8 / CMB_RADIUS

!PRINT*, ACOS( COSTHETA_GRID_LSQ_UPPER(3)), 2.0_8 * Pi * 1 / NPHI_GRID, B_R(3,1)
!PRINT*, SV_STRUCTURES(3,1,SV_MODE,1)

CALL EVALUATE_B_R_GRID( NTHETA_LSQ, NPHI_GRID, GAUSS, HARMONICS, LMAX_OBS, LMAX_SV, B_R, GRAD_H_B_R, &
ALF_LSQ_LOWER, DALF_LSQ_LOWER, ONE_DIV_SIN_THETA_LSQ_LOWER )

CALL GET_FLOW(U_H,DIV_H_U_H,NTHETA_LSQ, NPHI_GRID, M_MODES, SV_MODE, M_wave_max, FLOW_CONSTANTS, DELTA, ICB_CMB_RATIO, SIN_THETA_LSQ_LOWER, COSTHETA_GRID_LSQ_LOWER, CHECK_SYMMETRY )
!Assemble SV:
DO I_THETA = 1, NTHETA_LSQ
DO I_PHI = 0, NPHI_GRID-1
B_R_DOT(I_THETA, I_PHI) = - U_H(I_THETA, I_PHI,1) * GRAD_H_B_R(I_THETA, I_PHI,1) - U_H(I_THETA, I_PHI,2) * GRAD_H_B_R(I_THETA, I_PHI,2) - B_R(I_THETA, I_PHI) * DIV_H_U_H(I_THETA, I_PHI)
ENDDO
ENDDO
SV_STRUCTURES(:,:,SV_MODE,2) = B_R_DOT(:,:) * 3600.0_8 * 24.0_8 * 365.0_8 / CMB_RADIUS

ENDDO

!PRINT*, GRAD_H_B_R(3,1,1:2)

ELSE  ! Perform a spherical harmonic filter


ALLOCATE( GAUSS_DOT(1:LMAX_SV * (LMAX_SV+2),2*M_wave_max+1))

ALLOCATE( FFT_TRANSFORM_ARRAY(1:NTHETA_GRID,0:NPHI_GRID-1) )

! FFTs in PHI, REAL to Half complex
CALL DFFTW_PLAN_MANY_R2R(PLAN_FFT_R2HC,       &  ! PLAN
1,                                            &  ! Rank of transforms
NPHI_GRID,                                    &  ! size of each transform
NTHETA_GRID,                                  &  ! how many
FFT_TRANSFORM_ARRAY,                          &  ! Input array
SIZE(FFT_TRANSFORM_ARRAY),                    &  ! subset size of transform (whole set)
NTHETA_GRID,                                  &  ! Stride for transform
1,                                            &  ! Gap between transforms in array
FFT_TRANSFORM_ARRAY,                          &  ! Output array
SIZE(FFT_TRANSFORM_ARRAY),                    &  ! subset size of output array
NTHETA_GRID,                                  &  ! output stride
1,                                            &  ! Gap between outputs for transforms.
FFTW_R2HC, TRANSFORM_OPTIMISATION)                        ! Transform type; flags


ALLOCATE(   COSTHETA_GRID_TRANSFORM(NTHETA_GRID), LEGENDRE_GAUW_TRANSFORM(NTHETA_GRID), &
ALF_TRANSFORM(NTHETA_GRID, NUM_LEGENDRE_SV), DALF_TRANSFORM(NTHETA_GRID, NUM_LEGENDRE_SV), &
TEMP_DALF(NTHETA_GRID, NUM_LEGENDRE_SV), TEMP_ALF(NTHETA_GRID, NUM_LEGENDRE_SV), LEGENDRE_INV_TRANSFORM(NTHETA_GRID, NUM_LEGENDRE_SV) , &
ONE_DIV_SIN_THETA_TRANSFORM(1:NTHETA_GRID), SIN_THETA_TRANSFORM(1:NTHETA_GRID)  )


CALL GAUWTS ( NTHETA_GRID, COSTHETA_GRID_TRANSFORM, LEGENDRE_GAUW_TRANSFORM )

! Get the Associated Legendre Functions (ALF) at the theta grid points, with their theta derivatives (DALF), of the ALF's up to degree LMAX_SV
CALL GET_LEGENDRE_FUNCTIONS( REAL(COSTHETA_GRID_TRANSFORM, KIND = EXTRA_LONG_REAL), LMAX_SV, MMAX_SV, TEMP_ALF, TEMP_DALF)
ALF_TRANSFORM = REAL(  TEMP_ALF, KIND = 8)
DALF_TRANSFORM = REAL( TEMP_DALF, KIND = 8)
ONE_DIV_SIN_THETA_TRANSFORM(:) = 1.0_LONG_REAL / SQRT( 1.0_LONG_REAL - COSTHETA_GRID_TRANSFORM(:)**2 )
SIN_THETA_TRANSFORM(:) = SQRT( 1.0_LONG_REAL - COSTHETA_GRID_TRANSFORM(:)**2 )

DO I = 1, NUM_LEGENDRE_SV
LEGENDRE_INV_TRANSFORM(1:NTHETA_GRID,I) = ALF_TRANSFORM(1:NTHETA_GRID,I) * LEGENDRE_GAUW_TRANSFORM(1:NTHETA_GRID)
ENDDO
DEALLOCATE( TEMP_ALF, TEMP_DALF)



ALLOCATE( U_H(1:NTHETA_GRID, 0:NPHI_GRID-1,1:2), DIV_H_U_H(1:NTHETA_GRID, 0:NPHI_GRID-1) )

! Evaluate B_r and its horizontal derivative on transform grid (theta, phi) grid
ALLOCATE( B_R_DOT(NTHETA_GRID, 0:NPHI_GRID-1), SPEC(1:LMAX_SV * (LMAX_SV + 2)) )
ALLOCATE( B_R(1:NTHETA_GRID, 0:NPHI_GRID-1), GRAD_H_B_R(1:NTHETA_GRID,0:NPHI_GRID-1,2) )

CALL EVALUATE_B_R_GRID( NTHETA_GRID, NPHI_GRID, GAUSS, HARMONICS, LMAX_OBS, LMAX_SV, B_R, GRAD_H_B_R, ALF_TRANSFORM, DALF_TRANSFORM, ONE_DIV_SIN_THETA_TRANSFORM )



DO SV_MODE = 1, 2 * M_wave_max + 1
CHECK_SYMMETRY = .TRUE.
CALL GET_FLOW(U_H,DIV_H_U_H,NTHETA_GRID, NPHI_GRID, M_MODES, SV_MODE, M_wave_max, FLOW_CONSTANTS, DELTA, ICB_CMB_RATIO, SIN_THETA_TRANSFORM, COSTHETA_GRID_TRANSFORM, CHECK_SYMMETRY )

!Assemble SV:
DO I_THETA = 1, NTHETA_GRID
IF( (90.0_8 - ACOS(COSTHETA_GRID_TRANSFORM(I_THETA))*180.0_8/Pi < LAT_MAX1 .AND.  90.0_8 - ACOS(COSTHETA_GRID_TRANSFORM(I_THETA))*180.0_8/Pi > Lat_min1) .OR. &
    (90.0_8 - ACOS(COSTHETA_GRID_TRANSFORM(I_THETA))*180.0_8/Pi < LAT_MAX2 .AND.  90.0_8 - ACOS(COSTHETA_GRID_TRANSFORM(I_THETA))*180.0_8/Pi > Lat_min2) ) THEN
DO I_PHI = 0, NPHI_GRID-1
B_R_DOT(I_THETA, I_PHI) = - U_H(I_THETA, I_PHI,1) * GRAD_H_B_R(I_THETA, I_PHI,1) - U_H(I_THETA, I_PHI,2) * GRAD_H_B_R(I_THETA, I_PHI,2) - B_R(I_THETA, I_PHI) * DIV_H_U_H(I_THETA, I_PHI)
ENDDO
ELSE
B_R_DOT(I_THETA, :)  = 0.0_8
ENDIF

ENDDO

! Transform
CALL REAL_2_SPEC( B_R_DOT, SPEC, LMAX_SV, LMAX_SV, HARMONICS, NPHI_GRID, NTHETA_GRID , LEGENDRE_INV_TRANSFORM )

! The array SPEC contains the spherical harmonic transform of B_R^DOT.



! Evaluate Gauss coefficients for B_r_dot in nT/yr
DO I = 1, LMAX_SV * (LMAX_SV+2)
GAUSS_DOT(I,SV_MODE) = SPEC(I) * (CMB_RADIUS/ES_RADIUS)**(HARMONICS(I)%L + 2) / REAL( HARMONICS(I)%L + 1, KIND = 8)
ENDDO

! Dimensionalise to nT/yr given a flow in m/s (and scale to the core)
GAUSS_DOT(:,SV_MODE) = GAUSS_DOT(:,SV_MODE) * 3600.0_8 * 24.0_8 * 365.0_8 / CMB_RADIUS

! Re-evaluate on grid



CALL EVALUATE_B_R_GRID( NTHETA_LSQ, NPHI_GRID, GAUSS_DOT(:,SV_MODE), HARMONICS, LMAX_SV, LMAX_SV, SV_STRUCTURES(:,:,SV_MODE,1), NOT_NEEDED, &
ALF_LSQ_UPPER, DALF_LSQ_UPPER, ONE_DIV_SIN_THETA_LSQ_UPPER )
CALL EVALUATE_B_R_GRID( NTHETA_LSQ, NPHI_GRID, GAUSS_DOT(:,SV_MODE), HARMONICS, LMAX_SV, LMAX_SV, SV_STRUCTURES(:,:,SV_MODE,2), NOT_NEEDED, &
ALF_LSQ_LOWER, DALF_LSQ_LOWER, ONE_DIV_SIN_THETA_LSQ_LOWER )


ENDDO !SV MODE

CALL DFFTW_DESTROY_PLAN(PLAN_FFT_R2HC)
DEALLOCATE(FFT_TRANSFORM_ARRAY)

ENDIF


!PRINT*, 'Setting up matrix system'

ALLOCATE( MAT(1:2*M_wave_max+1,1:2*M_wave_max+1) , RHS(1:2*M_wave_max+1) )

DO I = 1, 2*M_wave_max+1
DO J = 1, 2*M_wave_max+1

Mat(I,J) = 0.0_8
DO I_THETA = 1, NTHETA_LSQ
DO I_PHI = 0, NPHI_GRID-1
Mat(I,J) = Mat(I,J) + SV_STRUCTURES(I_THETA, I_PHI,I,1) * SV_STRUCTURES(I_THETA, I_PHI,J,1) * LEGENDRE_GAUW_LSQ_UPPER(I_THETA)
ENDDO
ENDDO

DO I_THETA = 1, NTHETA_LSQ
DO I_PHI = 0, NPHI_GRID-1
Mat(I,J) = Mat(I,J) + SV_STRUCTURES(I_THETA, I_PHI,I,2) * SV_STRUCTURES(I_THETA, I_PHI,J,2) * LEGENDRE_GAUW_LSQ_LOWER(I_THETA)
ENDDO
ENDDO

Mat(I,J) = Mat(I,J) * 2.0_8 * Pi / REAL( NPHI_GRID, KIND = 8)

ENDDO
ENDDO


! Setup RHS
ALLOCATE( SV_OBS(1:NTHETA_LSQ, 0:NPHI_GRID-1), IPIV(1:2* M_wave_max+1) )
CALL EVALUATE_B_R_GRID( NTHETA_LSQ, NPHI_GRID, GAUSS_SV, HARMONICS, LMAX_SV, LMAX_SV, SV_OBS, NOT_NEEDED, ALF_LSQ_UPPER, DALF_LSQ_UPPER, ONE_DIV_SIN_THETA_LSQ_UPPER )

DO I = 1, 2*M_wave_max+1
RHS(I) = 0.0_8
DO I_THETA = 1, NTHETA_LSQ
DO I_PHI = 0, NPHI_GRID-1
RHS(I) = RHS(I) + SV_OBS(I_THETA, I_PHI) * SV_STRUCTURES(I_THETA, I_PHI,I,1) * LEGENDRE_GAUW_LSQ_UPPER(I_THETA)
ENDDO
ENDDO

ENDDO !I

CALL EVALUATE_B_R_GRID( NTHETA_LSQ, NPHI_GRID, GAUSS_SV, HARMONICS, LMAX_SV, LMAX_SV, SV_OBS, NOT_NEEDED, ALF_LSQ_LOWER, DALF_LSQ_LOWER, ONE_DIV_SIN_THETA_LSQ_LOWER )

DO I = 1, 2*M_wave_max+1
DO I_THETA = 1, NTHETA_LSQ
DO I_PHI = 0, NPHI_GRID-1
RHS(I) = RHS(I) + SV_OBS(I_THETA, I_PHI) * SV_STRUCTURES(I_THETA, I_PHI,I,2) * LEGENDRE_GAUW_LSQ_LOWER(I_THETA)
ENDDO
ENDDO

ENDDO !I


RHS(:) = RHS(:) * 2.0_8 * Pi / REAL( NPHI_GRID, KIND = 8)


!PRINT*, RHS
!PRINT*, MAT

!!WRITE(13,'(ES)') Mat
!WRITE(14,'(ES)') RHS


!PRINT*, 'WRITING PLOTTING DATA...'
!CALL WRITE_B_R_DOT(GAUSS_SV, GAUSS_DOT, GAUSS, LMAX_B_OBS, LMAX_SV, HARMONICS , MAX_SV_ES, MAX_B_DOT_ES)
!
!PRINT*, 'SCALED FLOW CAN HAVE UP TO MAX VALUE OF', AMPLITUDE * (MAX_SV_ES/MAX_B_DOT_ES),' m/s'


CALL DGETRF( 2 * M_wave_max+1, 2 * M_wave_max+1,  Mat, 2 * M_wave_max+1, IPIV, INFO)
IF( INFO .NE. 0) THEN
PRINT*, 'DGETRF FAILED, INFO ', INFO
STOP
ENDIF
CALL DGETRS('N', 2 * M_wave_max+1, 1, Mat, 2 * M_wave_max+1, IPIV, RHS, 2 * M_wave_max+1, INFO )

IF( INFO .NE. 0) THEN
PRINT*, 'DGETRS FAILED, INFO ', INFO
STOP
ENDIF

!PRINT*, 'OPTIMAL SOLUTION: M, AMPLITUDE (M>=0 IS COSINE, M<0 IS SINE) '
!DO I = 1, 2 * M_wave_max+1
!PRINT*, M_MODES(I), RHS(I)
!ENDDO

IF( .NOT. JUST_EVALUATE ) THEN
FLOW_COEFFS = RHS
ENDIF

! Find least squares value:

ALLOCATE( SV_OPT_CALC(1:NTHETA_LSQ,0:NPHI_GRID-1))

DO I_THETA = 1, NTHETA_LSQ
DO I_PHI = 0, NPHI_GRID-1
SV_OPT_CALC(I_THETA,I_PHI) = SUM( FLOW_COEFFS(:) * SV_STRUCTURES(I_THETA,I_PHI,:,1))
ENDDO
ENDDO
CALL EVALUATE_B_R_GRID( NTHETA_LSQ, NPHI_GRID, GAUSS_SV, HARMONICS, LMAX_SV, LMAX_SV, SV_OBS, NOT_NEEDED, ALF_LSQ_UPPER, DALF_LSQ_UPPER, ONE_DIV_SIN_THETA_LSQ_UPPER )
LSQ = 0.0_8
SV_SQ = 0.0_8
DO I_PHI = 0, NPHI_GRID - 1
LSQ = LSQ + SUM( (SV_OBS(:,I_PHI) - SV_OPT_CALC(:,I_PHI))**2 * LEGENDRE_GAUW_LSQ_UPPER(:) )
SV_SQ = SV_SQ + SUM( (SV_OBS(:,I_PHI))**2 * LEGENDRE_GAUW_LSQ_UPPER(:) )
ENDDO

DO I_THETA = 1, NTHETA_LSQ
DO I_PHI = 0, NPHI_GRID-1
SV_OPT_CALC(I_THETA,I_PHI) = SUM( FLOW_COEFFS(:) * SV_STRUCTURES(I_THETA,I_PHI,:,2))
ENDDO
ENDDO
CALL EVALUATE_B_R_GRID( NTHETA_LSQ, NPHI_GRID, GAUSS_SV, HARMONICS, LMAX_SV, LMAX_SV, SV_OBS, NOT_NEEDED, ALF_LSQ_LOWER, DALF_LSQ_LOWER, ONE_DIV_SIN_THETA_LSQ_LOWER )
DO I_PHI = 0, NPHI_GRID - 1
LSQ = LSQ + SUM( (SV_OBS(:,I_PHI) - SV_OPT_CALC(:,I_PHI))**2 * LEGENDRE_GAUW_LSQ_LOWER(:) )
SV_SQ = SV_SQ + SUM( (SV_OBS(:,I_PHI))**2 * LEGENDRE_GAUW_LSQ_LOWER(:) )
ENDDO
LSQ = LSQ * 2.0_8 * Pi / REAL( NPHI_GRID, KIND = 8)
SV_SQ = SV_SQ * 2.0_8 * Pi / REAL( NPHI_GRID, KIND = 8)
DEALLOCATE( SV_OPT_CALC )
!WRITE(6,'(A,ES12.4,A)') 'LEAST SQUARES DEVIATION \int (SV - SV_syn)^2 sin(theta) dtheta dphi = ', LSQ, ' (nT/yr)^2'


! Find flow spectrum in terms of rms per wavenumber
IF(ALLOCATED(U_H)) DEALLOCATE(U_H)
IF(ALLOCATED(DIV_H_U_H)) DEALLOCATE( DIV_H_U_H)

ALLOCATE( U_H(1:NTHETA_LSQ,0:NPHI_GRID-1,1:2), DIV_H_U_H(1:NTHETA_LSQ,0:NPHI_GRID-1) )

KE_SPEC(:) = 0.0_8
! Find the flow
DO SV_MODE = 1, 2 * M_wave_max + 1
U_H(:,:,:) = 0.0_8
DIV_H_U_H(:,:) = 0.0_8

CHECK_SYMMETRY = .FALSE.
CALL GET_FLOW(U_H,DIV_H_U_H,NTHETA_LSQ, NPHI_GRID, M_MODES, SV_MODE, M_wave_max, FLOW_CONSTANTS, DELTA, ICB_CMB_RATIO, SIN_THETA_LSQ_UPPER, COSTHETA_GRID_LSQ_UPPER, CHECK_SYMMETRY )
!Assemble flow for single mode:
U_H = U_H * RHS(SV_MODE)
DO I_PHI = 0, NPHI_GRID - 1
KE_SPEC(SV_MODE) = KE_SPEC(SV_MODE) + SUM( (U_H(:,I_PHI,1)**2 + U_H(:,I_PHI,2)**2)  * LEGENDRE_GAUW_LSQ_UPPER(:) )
ENDDO

CALL GET_FLOW(U_H,DIV_H_U_H,NTHETA_LSQ, NPHI_GRID, M_MODES, SV_MODE, M_wave_max, FLOW_CONSTANTS, DELTA, ICB_CMB_RATIO, SIN_THETA_LSQ_LOWER, COSTHETA_GRID_LSQ_LOWER, CHECK_SYMMETRY )
!Assemble flow for single mode:
U_H = U_H * RHS(SV_MODE)
DO I_PHI = 0, NPHI_GRID - 1
KE_SPEC(SV_MODE) = KE_SPEC(SV_MODE) + SUM( (U_H(:,I_PHI,1)**2 + U_H(:,I_PHI,2)**2)  * LEGENDRE_GAUW_LSQ_LOWER(:) )
ENDDO

ENDDO
KE_SPEC = KE_SPEC * 2.0_8 * Pi / REAL( NPHI_GRID, KIND = 8)

! rescale in terms of (km/yr)^2:
KE_SPEC = KE_SPEC  * ( 3600.0_8 * 24.0_8 * 365.0_8 / 1000.0_8)**2

! Calculate the area by integrating 1 over the region
AREA = ( SUM( LEGENDRE_GAUW_LSQ_LOWER ) + SUM ( LEGENDRE_GAUW_LSQ_UPPER ) ) * 2.0 * Pi

KE_SPEC = KE_SPEC / AREA


! *******
! Visualise SV on VIS grid
!ALLOCATE( SV_OPT(1:NTHETA_VIS, 0:NPHI_VIS-1))
DEALLOCATE( U_H, DIV_H_U_H, B_R, B_R_DOT, GRAD_H_B_R)

ALLOCATE( U_H(1:NTHETA_VIS, 0:NPHI_VIS-1,1:2), DIV_H_U_H(1:NTHETA_VIS, 0:NPHI_VIS-1) )

! Evaluate B_r and its horizontal derivative on VIS grid (theta, phi) grid
ALLOCATE( B_R_DOT(NTHETA_VIS, 0:NPHI_VIS-1) )
ALLOCATE( B_R(1:NTHETA_VIS, 0:NPHI_VIS-1), GRAD_H_B_R(1:NTHETA_VIS,0:NPHI_VIS-1,2) )


ALLOCATE( TEMP_DALF(NTHETA_VIS, NUM_LEGENDRE_SV), TEMP_ALF(NTHETA_VIS, NUM_LEGENDRE_SV), COSTHETA_GRID_VIS(1:NTHETA_VIS), SIN_THETA_VIS(1:NTHETA_VIS), ONE_DIV_SIN_THETA_VIS(1:NTHETA_VIS) )
ALLOCATE( ALF_VIS(NTHETA_VIS, NUM_LEGENDRE_SV), DALF_VIS(NTHETA_VIS, NUM_LEGENDRE_SV) )
DO I = 1, NTHETA_VIS
COSTHETA_GRID_VIS(I) = COS( I * Pi / REAL( NTHETA_VIS+1, KIND = 8) )
ENDDO

CALL GET_LEGENDRE_FUNCTIONS( REAL(COSTHETA_GRID_VIS, KIND = EXTRA_LONG_REAL), LMAX_SV, MMAX_SV, TEMP_ALF, TEMP_DALF)
ALF_VIS = REAL(  TEMP_ALF, KIND = 8)
DALF_VIS = REAL( TEMP_DALF, KIND = 8)

SIN_THETA_VIS(:) = SQRT( 1.0_LONG_REAL - COSTHETA_GRID_VIS(:)**2 )
ONE_DIV_SIN_THETA_VIS(:) = 1.0_LONG_REAL / SIN_THETA_VIS(:)

! Evaluate SV_OBS on this grid:
CALL EVALUATE_B_R_GRID( NTHETA_VIS, NPHI_VIS, GAUSS_SV, HARMONICS, LMAX_SV, LMAX_SV, SV_OBS_VIS, GRAD_H_B_R, ALF_VIS, DALF_VIS, ONE_DIV_SIN_THETA_VIS )

IF( FILTER_SIGNAL .EQ. 1) THEN ! can re-use filtered Gauss coefficients here
SV_OPT(:,:) = 0.0_8
DO SV_MODE = 1, 2*M_wave_max+1
CALL EVALUATE_B_R_GRID( NTHETA_VIS, NPHI_VIS, GAUSS_DOT(:,SV_MODE), HARMONICS, LMAX_SV, LMAX_SV, B_R_DOT, GRAD_H_B_R, &
ALF_VIS, DALF_VIS, ONE_DIV_SIN_THETA_VIS )
SV_OPT = SV_OPT + FLOW_COEFFS(SV_MODE) * B_R_DOT(:,:)
ENDDO

ELSE

CALL EVALUATE_B_R_GRID( NTHETA_VIS, NPHI_VIS, GAUSS, HARMONICS, LMAX_OBS, LMAX_SV, B_R, GRAD_H_B_R, &
ALF_VIS, DALF_VIS, ONE_DIV_SIN_THETA_VIS )


B_R_DOT(:,:) = 0.0_8
DO SV_MODE = 1, 2 * M_wave_max + 1
CHECK_SYMMETRY = .TRUE.
CALL GET_FLOW(U_H,DIV_H_U_H,NTHETA_VIS, NPHI_VIS, M_MODES, SV_MODE, M_wave_max, FLOW_CONSTANTS, DELTA, ICB_CMB_RATIO, SIN_THETA_VIS, COSTHETA_GRID_VIS, CHECK_SYMMETRY )
!Assemble SV:
DO I_THETA = 1, NTHETA_VIS
DO I_PHI = 0, NPHI_VIS-1
B_R_DOT(I_THETA, I_PHI) = B_R_DOT(I_THETA, I_PHI) + FLOW_COEFFS(SV_MODE) * (-U_H(I_THETA, I_PHI,1) * GRAD_H_B_R(I_THETA, I_PHI,1) - &
U_H(I_THETA, I_PHI,2) * GRAD_H_B_R(I_THETA, I_PHI,2) - B_R(I_THETA, I_PHI) * DIV_H_U_H(I_THETA, I_PHI) )
ENDDO
ENDDO
ENDDO
SV_OPT = B_R_DOT(:,:) * 3600.0_8 * 24.0_8 * 365.0_8 / CMB_RADIUS
ENDIF

!ALLOCATE( FLOW(1:NTHETA_VIS,0:NPHI_VIS-1,1:2))
! Find the flow
FLOW(:,:,:) = 0.0_8
DO SV_MODE = 1, 2 * M_wave_max + 1
CHECK_SYMMETRY = .TRUE.
CALL GET_FLOW(U_H,DIV_H_U_H,NTHETA_VIS, NPHI_VIS, M_MODES, SV_MODE, M_wave_max, FLOW_CONSTANTS, DELTA, ICB_CMB_RATIO, SIN_THETA_VIS, COSTHETA_GRID_VIS, CHECK_SYMMETRY )
!Assemble SV:
DO I_THETA = 1, NTHETA_VIS
DO I_PHI = 0, NPHI_VIS-1
FLOW(I_THETA,I_PHI,1:2) = FLOW(I_THETA,I_PHI,1:2) + FLOW_COEFFS(SV_MODE) * U_H(I_THETA, I_PHI,1:2)
ENDDO
ENDDO
ENDDO
FLOW = FLOW / 1000.0_8 * 3600.0_8 * 24.0_8 * 365.0_8

IF( FILTER_SIGNAL .EQ. 1) THEN
! return Gauss coefficients of SV
DO I = 1, LMAX_SV * (LMAX_SV + 2)
GAUSS_SYN(I) = SUM( GAUSS_DOT(I,:) * FLOW_COEFFS(:) )
ENDDO
ENDIF

RETURN
END SUBROUTINE FIND_OPT_FLOW_MASKED

SUBROUTINE WRITE_BR (GAUSS, LMAX, HARMONICS, NGRID_THETA, NGRID_PHI, DATE, FILESTEM, GRID_TYPE )
! Writes Br in either lat/long or centred format.
!
IMPLICIT NONE


REAL( KIND = 8) :: GAUSS(:), DATE
TYPE ( HARMONIC_STRUCTURE ) :: HARMONICS(1:)
INTEGER :: LMAX, NGRID_THETA, NGRID_PHI
CHARACTER(1) :: GRID_TYPE
REAL( KIND = 8), ALLOCATABLE :: COSTHETA_GRID(:), ALF(:,:), DALF(:,:), ONE_DIV_SIN_THETA(:)
REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE :: TEMP_ALF(:,:), TEMP_DALF(:,:)
REAL( KIND = 8) :: PHI,  PHI_DEP, DERV_PHI_DEP,  BR_CS
INTEGER :: I_THETA, I_PHI, I_HARMONIC, INDEX_PLM, I
CHARACTER(300) :: FILENAME, FILESTEM

! setup grids
ALLOCATE( COSTHETA_GRID(1: NGRID_THETA))
DO I_THETA = 1, NGRID_THETA
COSTHETA_GRID(I_THETA) = COS(  I_THETA / REAL( NGRID_THETA + 1, KIND = 8 ) * Pi   )
ENDDO

ALLOCATE( ALF(1: NGRID_THETA, (LMAX + 1) * (LMAX + 2)/2), DALF(1: NGRID_THETA, (LMAX + 1) * (LMAX + 2)/2),  ONE_DIV_SIN_THETA(1: NGRID_THETA) )
ALLOCATE( TEMP_ALF(1: NGRID_THETA, (LMAX + 1) * (LMAX + 2)/2), TEMP_DALF(1: NGRID_THETA, (LMAX + 1) * (LMAX + 2)/2) )


CALL GET_LEGENDRE_FUNCTIONS( REAL(COSTHETA_GRID, KIND = EXTRA_LONG_REAL), LMAX, LMAX, TEMP_ALF, TEMP_DALF)
ALF = REAL( TEMP_ALF, KIND = 8)
DALF = REAL( TEMP_DALF, KIND = 8)

ONE_DIV_SIN_THETA(:) = 1.0_8 / SQRT( 1.0_8 - COSTHETA_GRID(:)**2 )

WRITE( FILENAME, '(A,A,F6.1)') TRIM(FILESTEM),'.', DATE
OPEN(16, FILE = FILENAME, STATUS = 'REPLACE', FORM = 'FORMATTED')

DO I_PHI = 1, NGRID_PHI
DO I_THETA = 1, NGRID_THETA

if( grid_type(1:1) .eq. 'C' .OR. grid_type(1:1) .eq. 'c') THEN
PHI = -Pi + Pi /REAL(NGRID_PHI, KIND = 8) + 2.0 * Pi / REAL(NGRID_PHI, KIND = 8) * (I_PHI-1)
ELSEIF( grid_type(1:1) .eq. 'L' .OR. grid_type(1:1) .eq. 'l') THEN
PHI = 0 + 2.0 * Pi / REAL(NGRID_PHI, KIND = 8) * (I_PHI-1)
ELSE
PRINT*,'INCORRECT GRID_TYPE'
STOP
ENDIF

BR_CS = 0.0_8

DO I = 1, LMAX * (LMAX + 2)
! evaluate B at core surface
IF( HARMONICS(I)%SINCOS .EQ. SINE_HARMONIC ) THEN
PHI_DEP = SIN(  HARMONICS(I)%M * PHI )
DERV_PHI_DEP = HARMONICS(I)%M * COS(  HARMONICS(I)%M * PHI )
ELSE
PHI_DEP = COS(  HARMONICS(I)%M * PHI )
DERV_PHI_DEP = -HARMONICS(I)%M * SIN(  HARMONICS(I)%M * PHI)
ENDIF

INDEX_PLM = HARMONICS(I)%M * LMAX +  (HARMONICS(I)%M * (3-HARMONICS(I)%M) ) /2 + 1 + (HARMONICS(I)%L - HARMONICS(I)%M)

BR_CS = BR_CS + GAUSS(I) *  ALF(I_THETA, INDEX_PLM) * PHI_DEP * REAL(HARMONICS(I)%L + 1, KIND = 8) * (ES_RADIUS / CMB_RADIUS)**(HARMONICS(I)%L+2)


ENDDO
WRITE(16,'(2F8.2,ES15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi,  BR_CS
ENDDO
ENDDO

CLOSE(16)

RETURN
END SUBROUTINE WRITE_BR

   END MODULE SUBS